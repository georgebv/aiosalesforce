{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p> \u26a1 aiosalesforce \u26a1 </p> <p> Asynchronous Python client for Salesforce APIs </p> <p> </p> <p><code>aiosalesforce</code> is a modern, production-ready asynchronous Python client for Salesforce APIs. It is built on top of the <code>httpx</code> library and provides a simple and intuitive API for interacting with Salesforce's APIs (such as REST and Bulk).</p> <ul> <li>Fast: designed from the ground up to be fully asynchronous </li> <li>Resilient: flexible and robust retrying configuration </li> <li>Fully typed: every part of the library is fully typed and annotated </li> <li>Intuitive: API follows naming conventions of Salesforce's APIs while   staying idiomatic to Python </li> <li>Salesforce first: built with years of experience working with the Salesforce API   it is configured to work out of the box and incorporates best practices and   latest Salesforce API features </li> <li>Track your API usage: built-in support for tracking Salesforce API usage   </li> </ul>"},{"location":"#supported-apis","title":"Supported APIs","text":"API Status Description SOQL Query \u2705 Execute SOQL queries sObject \u2705 CRUD operations on Salesforce objects Composite Batch \u2705 Execute multiple independent subrequests Composite \u2705 Execute multiple dependent subrequests Composite Graph \ud83d\udd52 Execute multiple composite graphs sObject Tree \ud83d\udd52 Create one or more sObject trees sObject Collections \ud83d\udd52 Execute multiple sObject operations Bulk API 1.0 \u274c Not planned (use Bulk API 2.0) Bulk API 2.0 \u2705 Bulk injest and query operations"},{"location":"#requirements","title":"Requirements","text":"<p><code>aiosalesforce</code> depends on:</p> <ul> <li>Python 3.11+</li> <li>httpx</li> <li>orjson</li> </ul> <p>Optional dependencies:</p> <ul> <li>PyJWT</li> <li>cryptography</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install aiosalesforce\n</code></pre> <p>To use the JWT Bearer Flow authentication install with the <code>jwt</code> extra:</p> <pre><code>pip install aiosalesforce[jwt]\n</code></pre>"},{"location":"#demo","title":"Demo","text":"<p>Follow the steps below to create a simple script that authenticates against Salesforce and performs basic operations such as creating a record, reading a record, and executing a SOQL query.</p>"},{"location":"#authenticate","title":"Authenticate","text":"<p>First, we need to authenticate against Salesforce. For this example, we will use the <code>SoapLogin</code> authentication method.</p> <pre><code>import asyncio\n\nfrom aiosalesforce import Salesforce, SoapLogin\nfrom httpx import AsyncClient\n\nauth = SoapLogin(\n    username=\"your-username\",\n    password=\"your-password\",\n    security_token=\"your-security-token\",\n)\n</code></pre>"},{"location":"#create-salesforce-client","title":"Create Salesforce client","text":"<p>Next, we create a new Salesforce client using the <code>Salesforce</code> class. Notice two additional parameters:</p> <ul> <li><code>client</code> - an instance of <code>httpx.AsyncClient</code> used to make HTTP requests</li> <li><code>base_url</code> - the base URL of your Salesforce instance</li> </ul> <p>Since we are writing an asynchronous application, we need to wrap everything in an <code>async</code> function. Subsequent sections are written as a continuation of the <code>main</code> function.</p> <pre><code>async def main():\n    async with AsyncClient() as client:\n        salesforce = Salesforce(\n            client,\n            base_url=\"https://your-instance.my.salesforce.com\",\n            auth=auth,\n        )\n</code></pre>"},{"location":"#create-a-record","title":"Create a record","text":"<p>Let's create a new Contact in Salesforce. To do this, we will use the <code>create</code> method of the <code>sobject</code> api:</p> <pre><code>contact_id = await salesforce.sobject.create(\n    \"Contact\",\n    {\n        \"FirstName\": \"John\",\n        \"LastName\": \"Doe\",\n        \"Email\": \"john.doe@example.com\",\n    },\n)\nprint(f\"Created Contact with ID: {contact_id}\")\n</code></pre> <p>This will output something like:</p> <pre><code>Created Contact with ID: 0035e00000Bv2tPAAR\n</code></pre>"},{"location":"#read-a-record","title":"Read a record","text":"<p>To read a record by ID, we will use the <code>get</code> method of the <code>sobject</code> api:</p> <pre><code>contact = await salesforce.sobject.get(\"Contact\", contact_id)\nprint(contact)\n</code></pre> <p>This will return a dictionary with the Contact details (truncated for brevity):</p> <pre><code>{\n    \"Id\": \"0035e00000Bv2tPAAR\",\n    \"FirstName\": \"John\",\n    \"LastName\": \"Doe\",\n    \"Email\": \"john.doe@example.com\",\n    ...\n}\n</code></pre>"},{"location":"#execute-a-soql-query","title":"Execute a SOQL query","text":"<p>Finally, let's execute a SOQL query to retrieve all Contacts:</p> <pre><code>async for record in salesforce.query(\"SELECT Id, Name FROM Contact\"):\n    print(record)\n</code></pre> <p>This will create an asynchronous generator yielding records as a dictionaries:</p> <pre><code>{\"Id\": \"0035e00000Bv2tPAAR\", \"Name\": \"John Doe\"}\n{\"Id\": \"0035e00000Bv2tPAAQ\", \"Name\": \"Jane Doe\"}\n{\"Id\": \"0035e00000Bv2tPAAP\", \"Name\": \"Alice Smith\"}\n...\n</code></pre>"},{"location":"#putting-it-all-together","title":"Putting it all together","text":"<p>Putting everything you learned above together, a simple script may look like this:</p> <pre><code>import asyncio\n\nfrom aiosalesforce import Salesforce\nfrom aiosalesforce.auth import SoapLogin\nfrom httpx import AsyncClient\n\n# Reuse authentication session across multiple clients (refreshes automagically)\nauth = SoapLogin(\n    username=\"your-username\",\n    password=\"your-password\",\n    security_token=\"your-security-token\",\n)\n\nasync def main():\n    async with AsyncClient() as client:\n        # Create a Salesforce client\n        salesforce = Salesforce(\n            client,\n            base_url=\"https://your-instance.my.salesforce.com\",\n            auth=auth,\n        )\n\n        # Create a new Contact\n        contact_id = await salesforce.sobject.create(\n            \"Contact\",\n            {\n                \"FirstName\": \"John\",\n                \"LastName\": \"Doe\",\n                \"Email\": \"john.doe@example.com\",\n            },\n        )\n        print(f\"Created Contact with ID: {contact_id}\")\n\n        # Read Contact by ID\n        contact = await salesforce.sobject.get(\"Contact\", contact_id)\n        print(contact)\n\n        # Execute a SOQL query\n        async for record in salesforce.query(\"SELECT Id, Name FROM Contact\"):\n            print(record)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"api-reference/auth/","title":"Authentication","text":""},{"location":"api-reference/auth/#aiosalesforce.auth.Auth","title":"<code>Auth</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Base class for Salesforce authentication.</p> Source code in <code>src/aiosalesforce/auth/base.py</code> <pre><code>class Auth(ABC):\n    \"\"\"\n    Base class for Salesforce authentication.\n\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self.__access_token: str | None = None\n        self.__lock = asyncio.Lock()\n\n    @final\n    async def get_access_token(self, client: \"Salesforce\") -&gt; str:\n        \"\"\"\n        Get access token.\n\n        If this is the first time this method is called, it will acquire a new\n        access token from Salesforce.\n\n        Parameters\n        ----------\n        client : Salesforce\n            Salesforce client.\n\n        Returns\n        -------\n        str\n            Access token\n\n        \"\"\"\n        async with self.__lock:\n            if self.__access_token is None:\n                logger.debug(\n                    \"Acquiring new access token using %s for %s\",\n                    self.__class__.__name__,\n                    client.base_url,\n                )\n                self.__access_token = await self._acquire_new_access_token(client)\n            elif self.expired:\n                logger.debug(\n                    \"Token expired, refreshing access token using %s for %s\",\n                    self.__class__.__name__,\n                    client.base_url,\n                )\n                self.__access_token = await self._refresh_access_token(client)\n            return self.__access_token\n\n    @final\n    async def refresh_access_token(self, client: \"Salesforce\") -&gt; str:\n        \"\"\"\n        Refresh the access token.\n\n        Parameters\n        ----------\n        client : Salesforce\n            Salesforce client.\n\n        Returns\n        -------\n        str\n            Access token\n\n        \"\"\"\n        if self.__access_token is None:\n            raise RuntimeError(\"No access token to refresh\")\n        token_before_refresh = self.__access_token\n        async with self.__lock:\n            if self.__access_token == token_before_refresh:\n                logger.debug(\n                    \"Refreshing access token using %s for %s\",\n                    self.__class__.__name__,\n                    client.base_url,\n                )\n                self.__access_token = await self._refresh_access_token(client)\n            return self.__access_token\n\n    @abstractmethod\n    async def _acquire_new_access_token(self, client: \"Salesforce\") -&gt; str:\n        \"\"\"\n        Acquire a new access token from Salesforce.\n\n        Implementation is responsible for emitting RequestEvent and ResponseEvent.\n\n        Parameters\n        ----------\n        client : Salesforce\n            Salesforce client.\n\n        Returns\n        -------\n        str\n            Access token\n\n        \"\"\"\n\n    async def _refresh_access_token(self, client: \"Salesforce\") -&gt; str:\n        \"\"\"\n        Refresh the access token.\n\n        Implementation is responsible for emitting RequestEvent and ResponseEvent.\n\n        Parameters\n        ----------\n        client : Salesforce\n            Salesforce client.\n\n        Returns\n        -------\n        str\n            Access token\n\n        \"\"\"\n        return await self._acquire_new_access_token(client)\n\n    @property\n    def expired(self) -&gt; bool:\n        \"\"\"True if the access token is expired.\"\"\"\n        if self.__access_token is None:  # pragma: no cover\n            raise RuntimeError(\"Cannot check expiration of a non-existent access token\")\n        # By default, assumes the access token never expires\n        # Salesforce client automatically refreshes the token after 401 response\n        return False\n</code></pre>"},{"location":"api-reference/auth/#aiosalesforce.auth.Auth.expired","title":"<code>expired: bool</code>  <code>property</code>","text":"<p>True if the access token is expired.</p>"},{"location":"api-reference/auth/#aiosalesforce.auth.Auth.get_access_token","title":"<code>get_access_token(client)</code>  <code>async</code>","text":"<p>Get access token.</p> <p>If this is the first time this method is called, it will acquire a new access token from Salesforce.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Salesforce</code> <p>Salesforce client.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Access token</p> Source code in <code>src/aiosalesforce/auth/base.py</code> <pre><code>@final\nasync def get_access_token(self, client: \"Salesforce\") -&gt; str:\n    \"\"\"\n    Get access token.\n\n    If this is the first time this method is called, it will acquire a new\n    access token from Salesforce.\n\n    Parameters\n    ----------\n    client : Salesforce\n        Salesforce client.\n\n    Returns\n    -------\n    str\n        Access token\n\n    \"\"\"\n    async with self.__lock:\n        if self.__access_token is None:\n            logger.debug(\n                \"Acquiring new access token using %s for %s\",\n                self.__class__.__name__,\n                client.base_url,\n            )\n            self.__access_token = await self._acquire_new_access_token(client)\n        elif self.expired:\n            logger.debug(\n                \"Token expired, refreshing access token using %s for %s\",\n                self.__class__.__name__,\n                client.base_url,\n            )\n            self.__access_token = await self._refresh_access_token(client)\n        return self.__access_token\n</code></pre>"},{"location":"api-reference/auth/#aiosalesforce.auth.Auth.refresh_access_token","title":"<code>refresh_access_token(client)</code>  <code>async</code>","text":"<p>Refresh the access token.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>Salesforce</code> <p>Salesforce client.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Access token</p> Source code in <code>src/aiosalesforce/auth/base.py</code> <pre><code>@final\nasync def refresh_access_token(self, client: \"Salesforce\") -&gt; str:\n    \"\"\"\n    Refresh the access token.\n\n    Parameters\n    ----------\n    client : Salesforce\n        Salesforce client.\n\n    Returns\n    -------\n    str\n        Access token\n\n    \"\"\"\n    if self.__access_token is None:\n        raise RuntimeError(\"No access token to refresh\")\n    token_before_refresh = self.__access_token\n    async with self.__lock:\n        if self.__access_token == token_before_refresh:\n            logger.debug(\n                \"Refreshing access token using %s for %s\",\n                self.__class__.__name__,\n                client.base_url,\n            )\n            self.__access_token = await self._refresh_access_token(client)\n        return self.__access_token\n</code></pre>"},{"location":"api-reference/auth/#aiosalesforce.auth.SoapLogin","title":"<code>SoapLogin</code>","text":"<p>             Bases: <code>Auth</code></p> <p>Authenticate using the SOAP login method.</p> <p>https://developer.salesforce.com/docs/atlas.en-us.api.meta/api/sforce_api_calls_login.htm</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>Username.</p> required <code>password</code> <code>str</code> <p>Password.</p> required <code>security_token</code> <code>str</code> <p>Security token.</p> required Source code in <code>src/aiosalesforce/auth/soap.py</code> <pre><code>class SoapLogin(Auth):\n    \"\"\"\n    Authenticate using the SOAP login method.\n\n    https://developer.salesforce.com/docs/atlas.en-us.api.meta/api/sforce_api_calls_login.htm\n\n    Parameters\n    ----------\n    username : str\n        Username.\n    password : str\n        Password.\n    security_token : str\n        Security token.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        username: str,\n        password: str,\n        security_token: str,\n    ):\n        super().__init__()\n        self.username = username\n        self.password = password\n        self.security_token = security_token\n\n        self._expiration_time: float | None = None\n\n    async def _acquire_new_access_token(self, client: \"Salesforce\") -&gt; str:\n        soap_xml_payload = f\"\"\"\n        &lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;\n        &lt;env:Envelope\n            xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\"\n            xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n            xmlns:env=\"http://schemas.xmlsoap.org/soap/envelope/\"&gt;\n            &lt;env:Body&gt;\n                &lt;n1:login xmlns:n1=\"urn:partner.soap.sforce.com\"&gt;\n                    &lt;n1:username&gt;{self.username}&lt;/n1:username&gt;\n                    &lt;n1:password&gt;{self.password}{self.security_token}&lt;/n1:password&gt;\n                &lt;/n1:login&gt;\n            &lt;/env:Body&gt;\n        &lt;/env:Envelope&gt;\n        \"\"\"\n        request = client.httpx_client.build_request(\n            \"POST\",\n            f\"{client.base_url}/services/Soap/u/{client.version}\",\n            content=textwrap.dedent(soap_xml_payload).strip(),\n            headers={\n                \"Content-Type\": \"text/xml; charset=UTF-8\",\n                \"SOAPAction\": \"login\",\n                \"Accept\": \"text/xml\",\n            },\n        )\n        await client.event_bus.publish_event(\n            RequestEvent(\n                type=\"request\",\n                request=request,\n            )\n        )\n        retry_context = client.retry_policy.create_context()\n        response = await retry_context.send_request_with_retries(\n            httpx_client=client.httpx_client,\n            event_bus=client.event_bus,\n            semaphore=client._semaphore,\n            request=request,\n        )\n        response_text = response.text\n        if not response.is_success:\n            try:\n                exception_code = str(\n                    re.search(\n                        r\"&lt;sf:exceptionCode&gt;(.+)&lt;\\/sf:exceptionCode&gt;\",\n                        response_text,\n                    ).groups()[0]  # type: ignore\n                )\n            except AttributeError:  # pragma: no cover\n                exception_code = None\n            try:\n                exception_message = str(\n                    re.search(\n                        r\"&lt;sf:exceptionMessage&gt;(.+)&lt;\\/sf:exceptionMessage&gt;\",\n                        response_text,\n                    ).groups()[0]  # type: ignore\n                )\n            except AttributeError:  # pragma: no cover\n                exception_message = response_text\n            raise AuthenticationError(\n                message=(\n                    f\"[{exception_code}] {exception_message}\"\n                    if exception_code\n                    else exception_message\n                ),\n                response=response,\n                error_code=exception_code,\n                error_message=exception_message,\n            )\n        match_ = re.search(r\"&lt;sessionId&gt;(.+)&lt;\\/sessionId&gt;\", response_text)\n        if match_ is None:  # pragma: no cover\n            raise AuthenticationError(\n                f\"Failed to parse sessionId from the SOAP response: {response_text}\",\n                response,\n            )\n        session_id = match_.groups()[0]\n\n        # Parse expiration time\n        match_ = re.search(\n            r\"&lt;sessionSecondsValid&gt;(.+)&lt;\\/sessionSecondsValid&gt;\",\n            response_text,\n        )\n        self._expiration_time = None\n        if match_ is not None:\n            try:\n                self._expiration_time = time.time() + int(match_.groups()[0])\n            except ValueError:  # pragma: no cover\n                pass\n\n        await client.event_bus.publish_event(\n            ResponseEvent(\n                type=\"response\",\n                response=response,\n            )\n        )\n        return session_id\n\n    @property\n    def expired(self) -&gt; bool:\n        super().expired\n        if self._expiration_time is None:  # pragma: no cover\n            return False\n        return self._expiration_time &lt;= time.time()\n</code></pre>"},{"location":"api-reference/auth/#aiosalesforce.auth.ClientCredentialsFlow","title":"<code>ClientCredentialsFlow</code>","text":"<p>             Bases: <code>Auth</code></p> <p>Authenticate using the OAuth 2.0 Client Credentials Flow.</p> <p>https://help.salesforce.com/s/articleView?id=sf.remoteaccess_oauth_client_credentials_flow.htm&amp;type=5</p> <p>Parameters:</p> Name Type Description Default <code>client_id</code> <code>str</code> <p>Client ID.</p> required <code>client_secret</code> <code>str</code> <p>Client secret.</p> required <code>timeout</code> <code>float</code> <p>Timeout for the access token in seconds. By default assumed to never expire.</p> <code>None</code> Source code in <code>src/aiosalesforce/auth/client_credentials_flow.py</code> <pre><code>class ClientCredentialsFlow(Auth):\n    \"\"\"\n    Authenticate using the OAuth 2.0 Client Credentials Flow.\n\n    https://help.salesforce.com/s/articleView?id=sf.remoteaccess_oauth_client_credentials_flow.htm&amp;type=5\n\n    Parameters\n    ----------\n    client_id : str\n        Client ID.\n    client_secret : str\n        Client secret.\n    timeout : float, optional\n        Timeout for the access token in seconds.\n        By default assumed to never expire.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        client_id: str,\n        client_secret: str,\n        timeout: float | None = None,\n    ) -&gt; None:\n        super().__init__()\n        self.client_id = client_id\n        self.client_secret = client_secret\n        self.timeout = timeout\n\n        self._expiration_time: float | None = None\n\n    async def _acquire_new_access_token(self, client: \"Salesforce\") -&gt; str:\n        request = client.httpx_client.build_request(\n            \"POST\",\n            f\"{client.base_url}/services/oauth2/token\",\n            headers={\n                \"Content-Type\": \"application/x-www-form-urlencoded\",\n                \"Accept\": \"application/json\",\n            },\n            data={\n                \"grant_type\": \"client_credentials\",\n                \"client_id\": self.client_id,\n                \"client_secret\": self.client_secret,\n            },\n        )\n        await client.event_bus.publish_event(\n            RequestEvent(\n                type=\"request\",\n                request=request,\n            )\n        )\n        retry_context = client.retry_policy.create_context()\n        response = await retry_context.send_request_with_retries(\n            httpx_client=client.httpx_client,\n            event_bus=client.event_bus,\n            semaphore=client._semaphore,\n            request=request,\n        )\n        if not response.is_success:\n            try:\n                response_json = json_loads(response.content)\n                error_code = response_json[\"error\"]\n                error_message = response_json[\"error_description\"]\n            except Exception:  # pragma: no cover\n                error_code = None\n                error_message = response.text\n            raise AuthenticationError(\n                f\"[{error_code}] {error_message}\" if error_code else error_message,\n                response=response,\n                error_code=error_code,\n                error_message=error_message,\n            )\n        await client.event_bus.publish_event(\n            ResponseEvent(\n                type=\"response\",\n                response=response,\n            )\n        )\n        if self.timeout is not None:\n            self._expiration_time = time.time() + self.timeout\n        return json_loads(response.content)[\"access_token\"]\n\n    @property\n    def expired(self) -&gt; bool:\n        super().expired\n        if self._expiration_time is None:  # pragma: no cover\n            return False\n        return self._expiration_time &lt;= time.time()\n</code></pre>"},{"location":"api-reference/client/","title":"Salesforce Client","text":""},{"location":"api-reference/client/#aiosalesforce.client.Salesforce","title":"<code>Salesforce</code>","text":"<p>Salesforce API client.</p> <p>Parameters:</p> Name Type Description Default <code>httpx_client</code> <code>AsyncClient</code> <p>HTTP client.</p> required <code>base_url</code> <code>str</code> <p>Base URL of the Salesforce instance. Must be in the format:</p> <ul> <li>Production    : https://[MyDomainName].my.salesforce.com</li> <li>Sandbox       : https://[MyDomainName]-[SandboxName].sandbox.my.salesforce.com</li> <li>Developer org : https://[MyDomainName].develop.my.salesforce.com</li> </ul> required <code>auth</code> <code>Auth</code> <p>Authentication object.</p> required <code>version</code> <code>str</code> <p>Salesforce API version. By default, uses the latest version.</p> <code>'60.0'</code> <code>event_hooks</code> <code>Iterable[Callable[[Event], Awaitable[None] | None]]</code> <p>Functions or coroutines executed when an event occurs. Hooks are executed concurrently and order of execution is not guaranteed. All hooks must be thread-safe.</p> <code>None</code> <code>retry_policy</code> <code>RetryPolicy</code> <p>Retry policy for requests. The default policy retries requests up to 3 times with exponential backoff and retries the following:</p> <ul> <li>httpx Transport errors (excluding timeouts)</li> <li>Server errors (5xx)</li> <li>Row lock errors</li> <li>Rate limit errors</li> </ul> <p>Set to None to disable retries.</p> <code>POLICY_DEFAULT</code> <code>concurrency_limit</code> <code>int</code> <p>Maximum number of simultaneous requests to Salesforce. The default is 100.</p> <code>100</code> Source code in <code>src/aiosalesforce/client.py</code> <pre><code>class Salesforce:\n    \"\"\"\n    Salesforce API client.\n\n    Parameters\n    ----------\n    httpx_client : httpx.AsyncClient\n        HTTP client.\n    base_url : str\n        Base URL of the Salesforce instance.\n        Must be in the format:\\n\n        * Production    : https://[MyDomainName].my.salesforce.com\n        * Sandbox       : https://[MyDomainName]-[SandboxName].sandbox.my.salesforce.com\n        * Developer org : https://[MyDomainName].develop.my.salesforce.com\\n\n    auth : Auth\n        Authentication object.\n    version : str, optional\n        Salesforce API version.\n        By default, uses the latest version.\n    event_hooks : Iterable[Callable[[Event], Awaitable[None] | None]], optional\n        Functions or coroutines executed when an event occurs.\n        Hooks are executed concurrently and order of execution is not guaranteed.\n        All hooks must be thread-safe.\n    retry_policy : RetryPolicy, optional\n        Retry policy for requests.\n        The default policy retries requests up to 3 times with exponential backoff\n        and retries the following:\\n\n        * httpx Transport errors (excluding timeouts)\n        * Server errors (5xx)\n        * Row lock errors\n        * Rate limit errors\\n\n        Set to None to disable retries.\n    concurrency_limit : int, optional\n        Maximum number of simultaneous requests to Salesforce.\n        The default is 100.\n\n    \"\"\"\n\n    httpx_client: httpx.AsyncClient\n    auth: Auth\n    event_bus: EventBus\n    retry_policy: RetryPolicy\n    _semaphore: asyncio.Semaphore\n\n    def __init__(\n        self,\n        httpx_client: httpx.AsyncClient,\n        base_url: str,\n        auth: Auth,\n        version: str = \"60.0\",\n        event_hooks: Iterable[Callable[[Event], Awaitable[None] | None]] | None = None,\n        retry_policy: RetryPolicy | None = POLICY_DEFAULT,\n        concurrency_limit: int = 100,\n    ) -&gt; None:\n        self.httpx_client = httpx_client\n        self.base_url = base_url\n        self.auth = auth\n        self.version = version\n\n        self.event_bus = EventBus(event_hooks)\n        self.retry_policy = retry_policy or RetryPolicy()\n        self._semaphore = asyncio.Semaphore(concurrency_limit)\n\n    @property\n    def version(self) -&gt; str:\n        \"\"\"API version in the format '60.0'.\"\"\"\n        return self.__version\n\n    @version.setter\n    def version(self, value: str) -&gt; None:\n        if not (match_ := re.fullmatch(r\"^(v)?(\\d+)(\\.(0)?)?$\", value)):\n            raise ValueError(\n                f\"Invalid Salesforce API version: '{value}'. \"\n                f\"A valid version should look like '60.0'.\"\n            )\n        self.__version = f\"{match_.groups()[1]}.0\"\n\n    @property\n    def base_url(self) -&gt; str:\n        \"\"\"Base URL in the format https://[subdomain(s)].my.salesforce.com\"\"\"\n        return self.__base_url\n\n    @base_url.setter\n    def base_url(self, value: str) -&gt; None:\n        match_ = re.fullmatch(\n            r\"(https://[a-zA-Z0-9-]+(\\.(sandbox|develop))?\\.my\\.salesforce\\.com).*\",\n            value.strip(\" \").lower(),\n        )\n        if not match_:\n            raise ValueError(\n                \"\\n\".join(\n                    [\n                        f\"Invalid Salesforce URL: {value}\",\n                        \"Supported formats:\",\n                        \"  Production    : https://[MyDomainName].my.salesforce.com\",\n                        \"  Sandbox       : https://[MyDomainName]-[SandboxName].sandbox.my.salesforce.com\",\n                        \"  Developer org : https://[MyDomainName].develop.my.salesforce.com\",\n                    ]\n                )\n            )\n        self.__base_url = str(match_.groups()[0])\n\n    @wraps(httpx.AsyncClient.request)\n    async def request(self, *args, **kwargs) -&gt; httpx.Response:\n        \"\"\"\n        Make an HTTP request to Salesforce.\n\n        Raises an appropriate exception if the request is not successful.\n\n        \"\"\"\n        request = self.httpx_client.build_request(*args, **kwargs)\n        access_token = await self.auth.get_access_token(self)\n        request.headers.update(\n            {\n                \"Authorization\": f\"Bearer {access_token}\",\n                \"User-Agent\": f\"aiosalesforce/{__version__}\",\n                \"Sforce-Call-Options\": f\"client=aiosalesforce/{__version__}\",\n                \"Sforce-Line-Ending\": \"LF\",\n            }\n        )\n        await self.event_bus.publish_event(\n            RequestEvent(type=\"request\", request=request)\n        )\n        retry_context = self.retry_policy.create_context()\n        response = await retry_context.send_request_with_retries(\n            httpx_client=self.httpx_client,\n            event_bus=self.event_bus,\n            semaphore=self._semaphore,\n            request=request,\n        )\n        if response.status_code == 401:\n            access_token = await self.auth.refresh_access_token(self)\n            request.headers[\"Authorization\"] = f\"Bearer {access_token}\"\n            response = await retry_context.send_request_with_retries(\n                httpx_client=self.httpx_client,\n                event_bus=self.event_bus,\n                semaphore=self._semaphore,\n                request=request,\n            )\n        if not response.is_success:\n            raise_salesforce_error(response)\n        if \"Warning\" in response.headers:\n            warnings.warn(response.headers[\"Warning\"], SalesforceWarning)\n        await self.event_bus.publish_event(\n            ResponseEvent(type=\"response\", response=response)\n        )\n        return response\n\n    async def get_limits(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get Salesforce org limits.\n\n        Returns\n        -------\n        dict\n            Salesforce org limits.\n\n        \"\"\"\n        response = await self.request(\n            \"GET\",\n            f\"{self.base_url}/services/data/v{self.version}/limits\",\n            headers={\"Accept\": \"application/json\"},\n        )\n        return json_loads(response.content)\n\n    async def query(\n        self,\n        query: str,\n        include_all_records: bool = False,\n    ) -&gt; AsyncIterator[dict]:\n        \"\"\"\n        Execute a SOQL query.\n\n        Parameters\n        ----------\n        query : str\n            SOQL query.\n        include_all_records : bool, default False\n            If True, includes all (active/deleted/archived) records.\n\n        Yields\n        -------\n        dict\n            Record.\n\n        \"\"\"\n        operation = \"query\" if not include_all_records else \"queryAll\"\n\n        next_url: str | None = None\n        while True:\n            if next_url is None:\n                response = await self.request(\n                    \"GET\",\n                    f\"{self.base_url}/services/data/v{self.version}/{operation}\",\n                    params={\"q\": query},\n                    headers={\"Accept\": \"application/json\"},\n                )\n            else:\n                response = await self.request(\n                    \"GET\",\n                    f\"{self.base_url}{next_url}\",\n                    headers={\"Accept\": \"application/json\"},\n                )\n            response_json: dict = json_loads(response.content)\n            for record in response_json[\"records\"]:\n                yield record\n            next_url = response_json.get(\"nextRecordsUrl\", None)\n            if next_url is None:\n                break\n\n    @cached_property\n    def sobject(self) -&gt; SobjectClient:\n        \"\"\"\n        Salesforce REST API sObject client.\n\n        Use this client to perform CRUD operations on individual sObjects.\n\n        \"\"\"\n        return SobjectClient(self)\n\n    @cached_property\n    def composite(self) -&gt; CompositeClient:\n        \"\"\"\n        Salesforce REST API composite client.\n\n        Use this client to perform composite operations:\n        * Composite Batch\n        * Composite\n        * Composite Graph\n        * sObject Tree\n        * sObject Collections\n\n        \"\"\"\n        return CompositeClient(self)\n\n    @cached_property\n    def bulk_v1(self) -&gt; NoReturn:\n        \"\"\"\n        Salesforce Bulk API 1.0 client.\n\n        Use this client to execute bulk ingest and query operations.\n\n        \"\"\"\n        raise NotImplementedError(\"Bulk API v1 is currently not supported\")\n\n    @cached_property\n    def bulk_v2(self) -&gt; BulkClientV2:\n        \"\"\"\n        Salesforce Bulk API 2.0 client.\n\n        Use this client to execute bulk ingest and query operations.\n\n        \"\"\"\n        return BulkClientV2(self)\n</code></pre>"},{"location":"api-reference/client/#aiosalesforce.client.Salesforce.version","title":"<code>version: str</code>  <code>property</code> <code>writable</code>","text":"<p>API version in the format '60.0'.</p>"},{"location":"api-reference/client/#aiosalesforce.client.Salesforce.base_url","title":"<code>base_url: str</code>  <code>property</code> <code>writable</code>","text":"<p>Base URL in the format https://[subdomain(s)].my.salesforce.com</p>"},{"location":"api-reference/client/#aiosalesforce.client.Salesforce.sobject","title":"<code>sobject: SobjectClient</code>  <code>cached</code> <code>property</code>","text":"<p>Salesforce REST API sObject client.</p> <p>Use this client to perform CRUD operations on individual sObjects.</p>"},{"location":"api-reference/client/#aiosalesforce.client.Salesforce.composite","title":"<code>composite: CompositeClient</code>  <code>cached</code> <code>property</code>","text":"<p>Salesforce REST API composite client.</p> <p>Use this client to perform composite operations: * Composite Batch * Composite * Composite Graph * sObject Tree * sObject Collections</p>"},{"location":"api-reference/client/#aiosalesforce.client.Salesforce.bulk_v1","title":"<code>bulk_v1: NoReturn</code>  <code>cached</code> <code>property</code>","text":"<p>Salesforce Bulk API 1.0 client.</p> <p>Use this client to execute bulk ingest and query operations.</p>"},{"location":"api-reference/client/#aiosalesforce.client.Salesforce.bulk_v2","title":"<code>bulk_v2: BulkClientV2</code>  <code>cached</code> <code>property</code>","text":"<p>Salesforce Bulk API 2.0 client.</p> <p>Use this client to execute bulk ingest and query operations.</p>"},{"location":"api-reference/client/#aiosalesforce.client.Salesforce.request","title":"<code>request(*args, **kwargs)</code>  <code>async</code>","text":"<p>Make an HTTP request to Salesforce.</p> <p>Raises an appropriate exception if the request is not successful.</p> Source code in <code>src/aiosalesforce/client.py</code> <pre><code>@wraps(httpx.AsyncClient.request)\nasync def request(self, *args, **kwargs) -&gt; httpx.Response:\n    \"\"\"\n    Make an HTTP request to Salesforce.\n\n    Raises an appropriate exception if the request is not successful.\n\n    \"\"\"\n    request = self.httpx_client.build_request(*args, **kwargs)\n    access_token = await self.auth.get_access_token(self)\n    request.headers.update(\n        {\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"User-Agent\": f\"aiosalesforce/{__version__}\",\n            \"Sforce-Call-Options\": f\"client=aiosalesforce/{__version__}\",\n            \"Sforce-Line-Ending\": \"LF\",\n        }\n    )\n    await self.event_bus.publish_event(\n        RequestEvent(type=\"request\", request=request)\n    )\n    retry_context = self.retry_policy.create_context()\n    response = await retry_context.send_request_with_retries(\n        httpx_client=self.httpx_client,\n        event_bus=self.event_bus,\n        semaphore=self._semaphore,\n        request=request,\n    )\n    if response.status_code == 401:\n        access_token = await self.auth.refresh_access_token(self)\n        request.headers[\"Authorization\"] = f\"Bearer {access_token}\"\n        response = await retry_context.send_request_with_retries(\n            httpx_client=self.httpx_client,\n            event_bus=self.event_bus,\n            semaphore=self._semaphore,\n            request=request,\n        )\n    if not response.is_success:\n        raise_salesforce_error(response)\n    if \"Warning\" in response.headers:\n        warnings.warn(response.headers[\"Warning\"], SalesforceWarning)\n    await self.event_bus.publish_event(\n        ResponseEvent(type=\"response\", response=response)\n    )\n    return response\n</code></pre>"},{"location":"api-reference/client/#aiosalesforce.client.Salesforce.get_limits","title":"<code>get_limits()</code>  <code>async</code>","text":"<p>Get Salesforce org limits.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Salesforce org limits.</p> Source code in <code>src/aiosalesforce/client.py</code> <pre><code>async def get_limits(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Get Salesforce org limits.\n\n    Returns\n    -------\n    dict\n        Salesforce org limits.\n\n    \"\"\"\n    response = await self.request(\n        \"GET\",\n        f\"{self.base_url}/services/data/v{self.version}/limits\",\n        headers={\"Accept\": \"application/json\"},\n    )\n    return json_loads(response.content)\n</code></pre>"},{"location":"api-reference/client/#aiosalesforce.client.Salesforce.query","title":"<code>query(query, include_all_records=False)</code>  <code>async</code>","text":"<p>Execute a SOQL query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>SOQL query.</p> required <code>include_all_records</code> <code>bool</code> <p>If True, includes all (active/deleted/archived) records.</p> <code>False</code> <p>Yields:</p> Type Description <code>dict</code> <p>Record.</p> Source code in <code>src/aiosalesforce/client.py</code> <pre><code>async def query(\n    self,\n    query: str,\n    include_all_records: bool = False,\n) -&gt; AsyncIterator[dict]:\n    \"\"\"\n    Execute a SOQL query.\n\n    Parameters\n    ----------\n    query : str\n        SOQL query.\n    include_all_records : bool, default False\n        If True, includes all (active/deleted/archived) records.\n\n    Yields\n    -------\n    dict\n        Record.\n\n    \"\"\"\n    operation = \"query\" if not include_all_records else \"queryAll\"\n\n    next_url: str | None = None\n    while True:\n        if next_url is None:\n            response = await self.request(\n                \"GET\",\n                f\"{self.base_url}/services/data/v{self.version}/{operation}\",\n                params={\"q\": query},\n                headers={\"Accept\": \"application/json\"},\n            )\n        else:\n            response = await self.request(\n                \"GET\",\n                f\"{self.base_url}{next_url}\",\n                headers={\"Accept\": \"application/json\"},\n            )\n        response_json: dict = json_loads(response.content)\n        for record in response_json[\"records\"]:\n            yield record\n        next_url = response_json.get(\"nextRecordsUrl\", None)\n        if next_url is None:\n            break\n</code></pre>"},{"location":"api-reference/events/","title":"Events","text":""},{"location":"api-reference/events/#aiosalesforce.events.EventBus","title":"<code>EventBus</code>","text":"<p>Event bus used to dispatch events to subscribed callbacks.</p> <p>Parameters:</p> Name Type Description Default <code>callbacks</code> <code>Iterable[Callable[[Event], Awaitable[None] | None]]</code> <p>Callbacks to subscribe to the event bus.</p> <code>None</code> Source code in <code>src/aiosalesforce/events/event_bus.py</code> <pre><code>class EventBus:\n    \"\"\"\n    Event bus used to dispatch events to subscribed callbacks.\n\n    Parameters\n    ----------\n    callbacks : Iterable[Callable[[Event], Awaitable[None] | None]], optional\n        Callbacks to subscribe to the event bus.\n\n    \"\"\"\n\n    _callbacks: set[CallbackType]\n\n    def __init__(self, callbacks: Iterable[CallbackType] | None = None) -&gt; None:\n        self._callbacks = set()\n        for callback in callbacks or []:\n            self.subscribe_callback(callback)\n\n    def subscribe_callback(self, callback: CallbackType) -&gt; None:\n        \"\"\"\n        Subscribe a callback to the event bus.\n\n        Parameters\n        ----------\n        callback : CallbackType\n            Function to be called when an event is published.\n\n        \"\"\"\n        self._callbacks.add(callback)\n\n    def unsubscribe_callback(self, callback: CallbackType) -&gt; None:\n        \"\"\"\n        Unsubscribe a callback from the event bus.\n\n        Parameters\n        ----------\n        callback : CallbackType\n            Function to be unsubscribed.\n\n        \"\"\"\n        self._callbacks.discard(callback)\n\n    @staticmethod\n    async def __dispatch_event_to_callback(\n        callback: CallbackType, event: Event\n    ) -&gt; None:\n        if inspect.iscoroutinefunction(callback):\n            await callback(event)\n        else:\n            await asyncio.to_thread(callback, event)\n\n    async def publish_event(self, event: Event) -&gt; None:\n        \"\"\"Publish an event and dispatch it to all subscribed callbacks.\"\"\"\n        async with asyncio.TaskGroup() as tg:\n            for callback in self._callbacks:\n                tg.create_task(self.__dispatch_event_to_callback(callback, event))\n</code></pre>"},{"location":"api-reference/events/#aiosalesforce.events.EventBus.subscribe_callback","title":"<code>subscribe_callback(callback)</code>","text":"<p>Subscribe a callback to the event bus.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>CallbackType</code> <p>Function to be called when an event is published.</p> required Source code in <code>src/aiosalesforce/events/event_bus.py</code> <pre><code>def subscribe_callback(self, callback: CallbackType) -&gt; None:\n    \"\"\"\n    Subscribe a callback to the event bus.\n\n    Parameters\n    ----------\n    callback : CallbackType\n        Function to be called when an event is published.\n\n    \"\"\"\n    self._callbacks.add(callback)\n</code></pre>"},{"location":"api-reference/events/#aiosalesforce.events.EventBus.unsubscribe_callback","title":"<code>unsubscribe_callback(callback)</code>","text":"<p>Unsubscribe a callback from the event bus.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>CallbackType</code> <p>Function to be unsubscribed.</p> required Source code in <code>src/aiosalesforce/events/event_bus.py</code> <pre><code>def unsubscribe_callback(self, callback: CallbackType) -&gt; None:\n    \"\"\"\n    Unsubscribe a callback from the event bus.\n\n    Parameters\n    ----------\n    callback : CallbackType\n        Function to be unsubscribed.\n\n    \"\"\"\n    self._callbacks.discard(callback)\n</code></pre>"},{"location":"api-reference/events/#aiosalesforce.events.EventBus.publish_event","title":"<code>publish_event(event)</code>  <code>async</code>","text":"<p>Publish an event and dispatch it to all subscribed callbacks.</p> Source code in <code>src/aiosalesforce/events/event_bus.py</code> <pre><code>async def publish_event(self, event: Event) -&gt; None:\n    \"\"\"Publish an event and dispatch it to all subscribed callbacks.\"\"\"\n    async with asyncio.TaskGroup() as tg:\n        for callback in self._callbacks:\n            tg.create_task(self.__dispatch_event_to_callback(callback, event))\n</code></pre>"},{"location":"api-reference/events/#aiosalesforce.events.Event","title":"<code>Event</code>  <code>dataclass</code>","text":"<p>Base class for all events.</p> Source code in <code>src/aiosalesforce/events/events.py</code> <pre><code>@dataclass\nclass Event:\n    \"\"\"Base class for all events.\"\"\"\n\n    type: Literal[\n        \"request\",\n        \"response\",\n        \"retry\",\n        \"rest_api_call_consumption\",\n        \"bulk_api_batch_consumption\",\n    ]\n</code></pre>"},{"location":"api-reference/events/#aiosalesforce.events.RequestEvent","title":"<code>RequestEvent</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Event</code></p> <p>Emitted before a request is sent for the first time.</p> Source code in <code>src/aiosalesforce/events/events.py</code> <pre><code>@dataclass\nclass RequestEvent(Event):\n    \"\"\"Emitted before a request is sent for the first time.\"\"\"\n\n    type: Literal[\"request\"]\n    request: Request\n</code></pre>"},{"location":"api-reference/events/#aiosalesforce.events.RetryEvent","title":"<code>RetryEvent</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Event</code>, <code>ResponseMixin</code></p> <p>Emitted immediately before a request is retried.</p> Source code in <code>src/aiosalesforce/events/events.py</code> <pre><code>@dataclass\nclass RetryEvent(Event, ResponseMixin):\n    \"\"\"Emitted immediately before a request is retried.\"\"\"\n\n    type: Literal[\"retry\"]\n    attempt: int\n    request: Request\n    response: Response | None = None\n    exception: Exception | None = None\n</code></pre>"},{"location":"api-reference/events/#aiosalesforce.events.ResponseEvent","title":"<code>ResponseEvent</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Event</code>, <code>ResponseMixin</code></p> <p>Emitted after an OK (status code &lt; 300) response is received.</p> Source code in <code>src/aiosalesforce/events/events.py</code> <pre><code>@dataclass\nclass ResponseEvent(Event, ResponseMixin):\n    \"\"\"Emitted after an OK (status code &lt; 300) response is received.\"\"\"\n\n    type: Literal[\"response\"]\n    response: Response\n</code></pre>"},{"location":"api-reference/events/#aiosalesforce.events.RestApiCallConsumptionEvent","title":"<code>RestApiCallConsumptionEvent</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Event</code>, <code>ResponseMixin</code></p> <p>Emitted after a REST API call is consumed.</p> Source code in <code>src/aiosalesforce/events/events.py</code> <pre><code>@dataclass\nclass RestApiCallConsumptionEvent(Event, ResponseMixin):\n    \"\"\"Emitted after a REST API call is consumed.\"\"\"\n\n    type: Literal[\"rest_api_call_consumption\"]\n    response: Response\n    count: int\n</code></pre>"},{"location":"api-reference/events/#aiosalesforce.events.BulkApiBatchConsumptionEvent","title":"<code>BulkApiBatchConsumptionEvent</code>  <code>dataclass</code>","text":"<p>             Bases: <code>Event</code>, <code>ResponseMixin</code></p> <p>Emitted after a Bulk API batch is consumed.</p> Source code in <code>src/aiosalesforce/events/events.py</code> <pre><code>@dataclass\nclass BulkApiBatchConsumptionEvent(Event, ResponseMixin):\n    \"\"\"Emitted after a Bulk API batch is consumed.\"\"\"\n\n    type: Literal[\"bulk_api_batch_consumption\"]\n    response: Response\n    count: int\n</code></pre>"},{"location":"api-reference/events/#aiosalesforce.events.events.ResponseMixin","title":"<code>ResponseMixin</code>","text":"<p>Mixin class providing properties for events which may have response.</p> Source code in <code>src/aiosalesforce/events/events.py</code> <pre><code>class ResponseMixin:\n    \"\"\"Mixin class providing properties for events which may have response.\"\"\"\n\n    response: Response | None\n\n    @property\n    def consumed(self) -&gt; int | None:\n        \"\"\"Number of API calls consumed in the current 24-hour period.\"\"\"\n        return self.__api_usage[0]\n\n    @property\n    def remaining(self) -&gt; int | None:\n        \"\"\"Number of API calls remaining in the current 24-hour period.\"\"\"\n        return self.__api_usage[1]\n\n    @cached_property\n    def __api_usage(self) -&gt; tuple[int, int] | tuple[None, None]:\n        if self.response is None:\n            return (None, None)\n        try:\n            match_ = re.fullmatch(\n                r\"^api-usage=(\\d+)/(\\d+)$\",\n                str(self.response.headers[\"Sforce-Limit-Info\"]).strip(),\n            )\n        except KeyError:\n            return (None, None)\n        if match_ is None:  # pragma: no cover\n            return (None, None)\n        consumed, remaining = match_.groups()\n        return int(consumed), int(remaining)\n</code></pre>"},{"location":"api-reference/events/#aiosalesforce.events.events.ResponseMixin.consumed","title":"<code>consumed: int | None</code>  <code>property</code>","text":"<p>Number of API calls consumed in the current 24-hour period.</p>"},{"location":"api-reference/events/#aiosalesforce.events.events.ResponseMixin.remaining","title":"<code>remaining: int | None</code>  <code>property</code>","text":"<p>Number of API calls remaining in the current 24-hour period.</p>"},{"location":"api-reference/exceptions/","title":"Exceptions","text":""},{"location":"api-reference/exceptions/#aiosalesforce.exceptions.SalesforceWarning","title":"<code>SalesforceWarning</code>","text":"<p>             Bases: <code>Warning</code></p> <p>Base class for all Salesforce warnings.</p> Source code in <code>src/aiosalesforce/exceptions.py</code> <pre><code>class SalesforceWarning(Warning):\n    \"\"\"Base class for all Salesforce warnings.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#aiosalesforce.exceptions.SalesforceError","title":"<code>SalesforceError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for all Salesforce errors.</p> Source code in <code>src/aiosalesforce/exceptions.py</code> <pre><code>class SalesforceError(Exception):\n    \"\"\"Base class for all Salesforce errors.\"\"\"\n\n    response: Response | None\n    error_code: str | None\n    error_message: str | None\n\n    def __init__(\n        self,\n        message: str,\n        response: Response | None = None,\n        error_code: str | None = None,\n        error_message: str | None = None,\n    ) -&gt; None:\n        super().__init__(message)\n        self.response = response\n        self.error_code = error_code\n        self.error_message = error_message\n</code></pre>"},{"location":"api-reference/exceptions/#aiosalesforce.exceptions.MoreThanOneRecordError","title":"<code>MoreThanOneRecordError</code>","text":"<p>             Bases: <code>SalesforceError</code></p> <p>Raised when more than one record is found by external ID.</p> Source code in <code>src/aiosalesforce/exceptions.py</code> <pre><code>class MoreThanOneRecordError(SalesforceError):\n    \"\"\"Raised when more than one record is found by external ID.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#aiosalesforce.exceptions.DuplicatesDetectedError","title":"<code>DuplicatesDetectedError</code>","text":"<p>             Bases: <code>SalesforceError</code></p> <p>Raised when duplicates are detected, e.g. when creating a new record.</p> Source code in <code>src/aiosalesforce/exceptions.py</code> <pre><code>class DuplicatesDetectedError(SalesforceError):\n    \"\"\"Raised when duplicates are detected, e.g. when creating a new record.\"\"\"\n\n    @property\n    def duplicates(self) -&gt; list[_DuplicateRecord]:\n        assert self.response is not None\n        response_json = json_loads(self.response.content)\n        return [\n            _DuplicateRecord(\n                id=match_record[\"record\"][\"Id\"],\n                sobject=match_record[\"record\"][\"attributes\"][\"type\"],\n                match_confidence=match_record[\"matchConfidence\"],\n                match_engine=match_result[\"matchEngine\"],\n                rule=match_result[\"rule\"],\n            )\n            for match_result in response_json[0][\"duplicateResult\"][\"matchResults\"]\n            for match_record in match_result[\"matchRecords\"]\n        ]\n</code></pre>"},{"location":"api-reference/exceptions/#aiosalesforce.exceptions.AuthenticationError","title":"<code>AuthenticationError</code>","text":"<p>             Bases: <code>SalesforceError</code></p> <p>Raised when authentication fails.</p> Source code in <code>src/aiosalesforce/exceptions.py</code> <pre><code>class AuthenticationError(SalesforceError):\n    \"\"\"Raised when authentication fails.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#aiosalesforce.exceptions.AuthorizationError","title":"<code>AuthorizationError</code>","text":"<p>             Bases: <code>SalesforceError</code></p> <p>Raised when user has insufficient permissions to perform an action.</p> Source code in <code>src/aiosalesforce/exceptions.py</code> <pre><code>class AuthorizationError(SalesforceError):\n    \"\"\"Raised when user has insufficient permissions to perform an action.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#aiosalesforce.exceptions.RequestLimitExceededError","title":"<code>RequestLimitExceededError</code>","text":"<p>             Bases: <code>SalesforceError</code></p> <p>Raised when org REST API request limit is exceeded.</p> Source code in <code>src/aiosalesforce/exceptions.py</code> <pre><code>class RequestLimitExceededError(SalesforceError):\n    \"\"\"Raised when org REST API request limit is exceeded.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#aiosalesforce.exceptions.NotFoundError","title":"<code>NotFoundError</code>","text":"<p>             Bases: <code>SalesforceError</code></p> <p>Raised when a resource is not found.</p> Source code in <code>src/aiosalesforce/exceptions.py</code> <pre><code>class NotFoundError(SalesforceError):\n    \"\"\"Raised when a resource is not found.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#aiosalesforce.exceptions.ServerError","title":"<code>ServerError</code>","text":"<p>             Bases: <code>SalesforceError</code></p> <p>Base class for 5xx errors.</p> Source code in <code>src/aiosalesforce/exceptions.py</code> <pre><code>class ServerError(SalesforceError):\n    \"\"\"Base class for 5xx errors.\"\"\"\n</code></pre>"},{"location":"api-reference/exceptions/#aiosalesforce.exceptions.raise_salesforce_error","title":"<code>raise_salesforce_error(response)</code>","text":"<p>Given an HTTP response, raise an appropriate SalesforceError.</p> <p>https://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/errorcodes.htm</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>HTTP response.</p> required <p>Raises:</p> Type Description <code>SalesforceError</code> Source code in <code>src/aiosalesforce/exceptions.py</code> <pre><code>def raise_salesforce_error(response: Response) -&gt; NoReturn:\n    \"\"\"\n    Given an HTTP response, raise an appropriate SalesforceError.\n\n    https://developer.salesforce.com/docs/atlas.en-us.api_rest.meta/api_rest/errorcodes.htm\n\n    Parameters\n    ----------\n    response : httpx.Response\n        HTTP response.\n\n    Raises\n    ------\n    SalesforceError\n\n    \"\"\"\n    try:\n        response_json = json_loads(response.content)\n        error_code = response_json[0][\"errorCode\"]\n        error_message = response_json[0][\"message\"]\n        if error_code == \"DUPLICATES_DETECTED\":\n            error_message = \"\\n\".join(\n                [\n                    error_message,\n                    *[\n                        \"  %s (%s, %s, %s)\"\n                        % (\n                            duplicate[\"id\"],\n                            f\"{duplicate['match_confidence']:.1f}%\",\n                            duplicate[\"match_engine\"],\n                            duplicate[\"rule\"],\n                        )\n                        for duplicate in DuplicatesDetectedError(\n                            \"\", response\n                        ).duplicates\n                    ],\n                ]\n            )\n    except Exception:\n        error_code = None\n        error_message = response.text\n\n    exc_class: type[SalesforceError]\n    match (response.status_code, error_code):\n        case (300, _):\n            exc_class = MoreThanOneRecordError\n            try:\n                records = [f\"  {record}\" for record in json_loads(response.content)]\n            except Exception as exc:\n                records = [f\"  Failed to parse response: {exc}\"]\n            if error_code is None:\n                error_message = \"\\n\".join(\n                    [\n                        \"More than one record found for external ID.\",\n                        f\"{response.url}\",\n                        *records,\n                    ]\n                )\n        case (_, \"REQUEST_LIMIT_EXCEEDED\"):\n            exc_class = RequestLimitExceededError\n        case (400, \"DUPLICATES_DETECTED\"):\n            exc_class = DuplicatesDetectedError\n        case (403, _):\n            exc_class = AuthorizationError\n        case (404, _):\n            exc_class = NotFoundError\n        case (status_code, _) if status_code &gt;= 500:\n            exc_class = ServerError\n        case _:\n            exc_class = SalesforceError\n\n    raise exc_class(\n        f\"[{error_code}] {error_message}\" if error_code else error_message,\n        response=response,\n        error_code=error_code,\n        error_message=error_message,\n    )\n</code></pre>"},{"location":"api-reference/retries/","title":"Retries","text":""},{"location":"api-reference/retries/#aiosalesforce.retries.RetryPolicy","title":"<code>RetryPolicy</code>","text":"<p>             Bases: <code>RetryBase</code></p> <p>Policy for retrying requests.</p> <p>Parameters:</p> Name Type Description Default <code>response_rules</code> <code>list[ResponseRule]</code> <p>Rules for retrying requests based on their responses.</p> <code>None</code> <code>exception_rules</code> <code>list[ExceptionRule]</code> <p>Rules for retrying requests after an exception.</p> <code>None</code> <code>max_retries</code> <code>int</code> <p>Maximum total number of retries. By default 3.</p> <code>3</code> <code>timeout</code> <code>float</code> <p>Maximum time to retry. By default 60 seconds. Timeout is best effort and may exceed the specified time by up to <code>backoff_max</code> seconds.</p> <code>60</code> <code>backoff_base</code> <code>float</code> <p>Base time to sleep between retries. By default 0.5 seconds.</p> <code>0.5</code> <code>backoff_factor</code> <code>float</code> <p>Factor to increase sleep time between retries. By default 2.</p> <code>2</code> <code>backoff_max</code> <code>float</code> <p>Maximum time to sleep between retries. By default 10 seconds.</p> <code>10</code> <code>backoff_jitter</code> <code>bool</code> <p>If True, adds jitter to sleep time. By default True.</p> <code>True</code> Source code in <code>src/aiosalesforce/retries/policy.py</code> <pre><code>class RetryPolicy(RetryBase):\n    \"\"\"\n    Policy for retrying requests.\n\n    Parameters\n    ----------\n    response_rules : list[ResponseRule], optional\n        Rules for retrying requests based on their responses.\n    exception_rules : list[ExceptionRule], optional\n        Rules for retrying requests after an exception.\n    max_retries : int, optional\n        Maximum total number of retries. By default 3.\n    timeout : float, optional\n        Maximum time to retry. By default 60 seconds.\n        Timeout is best effort and may exceed the specified time\n        by up to `backoff_max` seconds.\n    backoff_base : float, optional\n        Base time to sleep between retries. By default 0.5 seconds.\n    backoff_factor : float, optional\n        Factor to increase sleep time between retries. By default 2.\n    backoff_max : float, optional\n        Maximum time to sleep between retries. By default 10 seconds.\n    backoff_jitter : bool, optional\n        If True, adds jitter to sleep time. By default True.\n\n    \"\"\"\n\n    def create_context(self) -&gt; RetryContext:\n        \"\"\"\n        Create a new retry context.\n\n        Retry context is used to handle retries for a single request.\n\n        \"\"\"\n        return RetryContext(\n            response_rules=self.response_rules,\n            exception_rules=self.exception_rules,\n            max_retries=self.max_retries,\n            timeout=self.timeout,\n            backoff_base=self.backoff_base,\n            backoff_factor=self.backoff_factor,\n            backoff_max=self.backoff_max,\n            backoff_jitter=self.backoff_jitter,\n        )\n</code></pre>"},{"location":"api-reference/retries/#aiosalesforce.retries.RetryPolicy.create_context","title":"<code>create_context()</code>","text":"<p>Create a new retry context.</p> <p>Retry context is used to handle retries for a single request.</p> Source code in <code>src/aiosalesforce/retries/policy.py</code> <pre><code>def create_context(self) -&gt; RetryContext:\n    \"\"\"\n    Create a new retry context.\n\n    Retry context is used to handle retries for a single request.\n\n    \"\"\"\n    return RetryContext(\n        response_rules=self.response_rules,\n        exception_rules=self.exception_rules,\n        max_retries=self.max_retries,\n        timeout=self.timeout,\n        backoff_base=self.backoff_base,\n        backoff_factor=self.backoff_factor,\n        backoff_max=self.backoff_max,\n        backoff_jitter=self.backoff_jitter,\n    )\n</code></pre>"},{"location":"api-reference/retries/#aiosalesforce.retries.ExceptionRule","title":"<code>ExceptionRule</code>","text":"<p>             Bases: <code>Generic[E]</code></p> <p>Rule for deciding if a request should be retried after an exception.</p> <p>Parameters:</p> Name Type Description Default <code>exc_type</code> <code>type[Exception]</code> <p>Type of exception to retry.</p> required <code>func</code> <code>Callable[[Exception], Awaitable[bool] | bool] | None</code> <p>Function or coroutine to determine if the request should be retried. By default the provided exception is always retried.</p> <code>None</code> <code>max_retries</code> <code>int</code> <p>Maximum number of retries. By default 3.</p> <code>3</code> Source code in <code>src/aiosalesforce/retries/rules.py</code> <pre><code>class ExceptionRule(Generic[E]):\n    \"\"\"\n    Rule for deciding if a request should be retried after an exception.\n\n    Parameters\n    ----------\n    exc_type : type[Exception]\n        Type of exception to retry.\n    func : Callable[[Exception], Awaitable[bool]  |  bool] | None, optional\n        Function or coroutine to determine if the request should be retried.\n        By default the provided exception is always retried.\n    max_retries : int, optional\n        Maximum number of retries. By default 3.\n\n    \"\"\"\n\n    exception_type: type[E]\n    func: Callable[[E], Awaitable[bool] | bool]\n    max_retries: int\n\n    def __init__(\n        self,\n        exc_type: type[E],\n        func: Callable[[E], Awaitable[bool] | bool] | None = None,\n        /,\n        max_retries: int = 3,\n    ) -&gt; None:\n        if issubclass(exc_type, SalesforceError):\n            raise ValueError(\n                \"aiosalesforce exceptions cannot be retried by aiosalesforce because \"\n                \"they are raised at the end of the request lifecycle - after all \"\n                \"retries have been exhausted. This could lead to an infinite loop. \"\n                \"If you need to retry aiosalesforce exceptions, consider using \"\n                \"ResponseRule instead.\"\n            )\n        if exc_type is Exception:\n            raise ValueError(\"Retrying built-in Exception is not allowed.\")\n        self.exception_type = exc_type\n        self.func = func or (lambda _: True)\n        self.max_retries = max_retries\n\n    async def should_retry(self, exc: E) -&gt; bool:\n        \"\"\"\n        Determine if the request should be retried.\n\n        Parameters\n        ----------\n        exc : Exception\n            Exception from the request.\n\n        Returns\n        -------\n        bool\n            True if the request should be retried, False otherwise.\n\n        \"\"\"\n        if not isinstance(exc, self.exception_type):\n            return False\n        if inspect.iscoroutinefunction(self.func):\n            return await self.func(exc)\n        else:\n            return await asyncio.to_thread(\n                self.func,  # type: ignore\n                exc,\n            )\n</code></pre>"},{"location":"api-reference/retries/#aiosalesforce.retries.ExceptionRule.should_retry","title":"<code>should_retry(exc)</code>  <code>async</code>","text":"<p>Determine if the request should be retried.</p> <p>Parameters:</p> Name Type Description Default <code>exc</code> <code>Exception</code> <p>Exception from the request.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the request should be retried, False otherwise.</p> Source code in <code>src/aiosalesforce/retries/rules.py</code> <pre><code>async def should_retry(self, exc: E) -&gt; bool:\n    \"\"\"\n    Determine if the request should be retried.\n\n    Parameters\n    ----------\n    exc : Exception\n        Exception from the request.\n\n    Returns\n    -------\n    bool\n        True if the request should be retried, False otherwise.\n\n    \"\"\"\n    if not isinstance(exc, self.exception_type):\n        return False\n    if inspect.iscoroutinefunction(self.func):\n        return await self.func(exc)\n    else:\n        return await asyncio.to_thread(\n            self.func,  # type: ignore\n            exc,\n        )\n</code></pre>"},{"location":"api-reference/retries/#aiosalesforce.retries.ResponseRule","title":"<code>ResponseRule</code>","text":"<p>Rule for deciding if a request should be retried based its response.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[Response], Awaitable[bool] | bool]</code> <p>Function or coroutine to determine if the request should be retried.</p> required <code>max_retries</code> <code>int</code> <p>Maximum number of retries. By default 3.</p> <code>3</code> Source code in <code>src/aiosalesforce/retries/rules.py</code> <pre><code>class ResponseRule:\n    \"\"\"\n    Rule for deciding if a request should be retried based its response.\n\n    Parameters\n    ----------\n    func : Callable[[Response], Awaitable[bool] | bool]\n        Function or coroutine to determine if the request should be retried.\n    max_retries : int, optional\n        Maximum number of retries. By default 3.\n\n    \"\"\"\n\n    func: Callable[[Response], Awaitable[bool] | bool]\n    max_retries: int\n\n    def __init__(\n        self,\n        func: Callable[[Response], Awaitable[bool] | bool],\n        /,\n        max_retries: int = 3,\n    ) -&gt; None:\n        self.func = func\n        self.max_retries = max_retries\n\n    async def should_retry(self, response: Response) -&gt; bool:\n        \"\"\"\n        Determine if the request should be retried.\n\n        Parameters\n        ----------\n        response : Response\n            Response from the request.\n\n        Returns\n        -------\n        bool\n            True if the request should be retried, False otherwise.\n\n        \"\"\"\n        if inspect.iscoroutinefunction(self.func):\n            return await self.func(response)\n        else:\n            return await asyncio.to_thread(\n                self.func,  # type: ignore\n                response,\n            )\n</code></pre>"},{"location":"api-reference/retries/#aiosalesforce.retries.ResponseRule.should_retry","title":"<code>should_retry(response)</code>  <code>async</code>","text":"<p>Determine if the request should be retried.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>Response from the request.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the request should be retried, False otherwise.</p> Source code in <code>src/aiosalesforce/retries/rules.py</code> <pre><code>async def should_retry(self, response: Response) -&gt; bool:\n    \"\"\"\n    Determine if the request should be retried.\n\n    Parameters\n    ----------\n    response : Response\n        Response from the request.\n\n    Returns\n    -------\n    bool\n        True if the request should be retried, False otherwise.\n\n    \"\"\"\n    if inspect.iscoroutinefunction(self.func):\n        return await self.func(response)\n    else:\n        return await asyncio.to_thread(\n            self.func,  # type: ignore\n            response,\n        )\n</code></pre>"},{"location":"api-reference/retries/#aiosalesforce.retries.policy.RetryContext","title":"<code>RetryContext</code>","text":"<p>             Bases: <code>RetryBase</code></p> <p>Context for handling retries for a single request.</p> Source code in <code>src/aiosalesforce/retries/policy.py</code> <pre><code>class RetryContext(RetryBase):\n    \"\"\"Context for handling retries for a single request.\"\"\"\n\n    __slots__ = (\"start\", \"retry_count\")\n\n    start: float\n    retry_count: RetryCounts\n\n    def __init__(\n        self,\n        response_rules: list[ResponseRule],\n        exception_rules: list[ExceptionRule],\n        max_retries: int,\n        timeout: float,\n        backoff_base: float,\n        backoff_factor: float,\n        backoff_max: float,\n        backoff_jitter: bool,\n    ) -&gt; None:\n        super().__init__(\n            response_rules=response_rules,\n            exception_rules=exception_rules,\n            max_retries=max_retries,\n            timeout=timeout,\n            backoff_base=backoff_base,\n            backoff_factor=backoff_factor,\n            backoff_max=backoff_max,\n            backoff_jitter=backoff_jitter,\n        )\n\n        self.start = time.time()\n        self.retry_count = {\n            \"total\": 0,\n            \"response\": {rule: 0 for rule in self.response_rules},\n            \"exception\": {rule: 0 for rule in self.exception_rules},\n        }\n\n    async def send_request_with_retries(\n        self,\n        httpx_client: AsyncClient,\n        event_bus: EventBus,\n        semaphore: asyncio.Semaphore,\n        request: Request,\n    ) -&gt; Response:\n        \"\"\"\n        Send a request and retry it if necessary in accordance with the retry policy.\n\n        Does not guarantee that the returned response is OK (status code &lt; 300),\n        only that the request was retried according to the policy.\n\n        Emits the following events:\\n\n        * RetryEvent if the request is retried\n        * RestApiCallConsumptionEvent for each request\n            that did not raise an exception\n\n        Parameters\n        ----------\n        httpx_client : AsyncClient\n            HTTP client to send the request.\n        event_bus : EventBus\n            Event bus to publish events.\n        semaphore : asyncio.Semaphore\n            Semaphore to limit the number of simultaneous requests.\n        request : Request\n            Request to send.\n\n        Returns\n        -------\n        Response\n            Response from the request.\n            Not guaranteed to be OK (status code &lt; 300).\n\n        \"\"\"\n        while True:\n            try:\n                async with semaphore:\n                    response = await httpx_client.send(request)\n            except Exception as exc:\n                if await self.should_retry(exc):\n                    await asyncio.gather(\n                        self.sleep(),\n                        event_bus.publish_event(\n                            RetryEvent(\n                                type=\"retry\",\n                                attempt=self.retry_count[\"total\"],\n                                request=request,\n                                exception=exc,\n                            )\n                        ),\n                    )\n                    continue\n                raise\n            await event_bus.publish_event(\n                RestApiCallConsumptionEvent(\n                    type=\"rest_api_call_consumption\",\n                    response=response,\n                    count=1,\n                )\n            )\n            if not response.is_success and await self.should_retry(response):\n                await asyncio.gather(\n                    self.sleep(),\n                    event_bus.publish_event(\n                        RetryEvent(\n                            type=\"retry\",\n                            attempt=self.retry_count[\"total\"],\n                            request=request,\n                            response=response,\n                        )\n                    ),\n                )\n                continue\n            return response\n\n    async def should_retry(self, value: Response | Exception) -&gt; bool:\n        \"\"\"\n        Determine if the request should be retried.\n\n        If the request should be retried, the total retry count and the retry count\n        for the rule responsible for the retry are incremented.\n\n        Parameters\n        ----------\n        value : Response | Exception\n            Response or Exception from the request.\n\n        Returns\n        -------\n        bool\n            True if the request should be retried, False otherwise.\n\n        \"\"\"\n        if (\n            self.retry_count[\"total\"] &gt;= self.max_retries\n            or time.time() - self.start &gt; self.timeout\n        ):\n            return False\n        condition: bool = False\n        match value:\n            case Response():\n                condition = await self.__evaluate_response_rules(value)\n            case Exception():\n                condition = await self.__evaluate_exception_rules(value)\n            case _:  # pragma: no cover\n                raise TypeError(\"Value must be a Response or an Exception\")\n        if condition:\n            self.retry_count[\"total\"] += 1\n        return condition\n\n    async def __evaluate_response_rules(self, response: Response) -&gt; bool:\n        for rule in self.response_rules:\n            if self.retry_count[\"response\"][\n                rule\n            ] &lt; rule.max_retries and await rule.should_retry(response):\n                self.retry_count[\"response\"][rule] += 1\n                return True\n        return False\n\n    async def __evaluate_exception_rules(self, exception: Exception) -&gt; bool:\n        for rule in self.exception_rules:\n            if self.retry_count[\"exception\"][rule] &gt;= rule.max_retries:\n                return False\n            if await rule.should_retry(exception):\n                self.retry_count[\"exception\"][rule] += 1\n                return True\n        return False\n\n    async def sleep(self) -&gt; None:\n        \"\"\"Sleep between retries based on the backoff policy.\"\"\"\n        # (total - 1) because this is called after incrementing the total count\n        sleep_time = min(\n            self.backoff_base\n            * (self.backoff_factor ** (self.retry_count[\"total\"] - 1)),\n            self.backoff_max,\n        )\n        if self.backoff_jitter:\n            sleep_time = random.uniform(0, sleep_time)  # noqa: S311\n        await asyncio.sleep(sleep_time)\n</code></pre>"},{"location":"api-reference/retries/#aiosalesforce.retries.policy.RetryContext.send_request_with_retries","title":"<code>send_request_with_retries(httpx_client, event_bus, semaphore, request)</code>  <code>async</code>","text":"<p>Send a request and retry it if necessary in accordance with the retry policy.</p> <p>Does not guarantee that the returned response is OK (status code &lt; 300), only that the request was retried according to the policy.</p> <p>Emits the following events:</p> <ul> <li>RetryEvent if the request is retried</li> <li>RestApiCallConsumptionEvent for each request     that did not raise an exception</li> </ul> <p>Parameters:</p> Name Type Description Default <code>httpx_client</code> <code>AsyncClient</code> <p>HTTP client to send the request.</p> required <code>event_bus</code> <code>EventBus</code> <p>Event bus to publish events.</p> required <code>semaphore</code> <code>Semaphore</code> <p>Semaphore to limit the number of simultaneous requests.</p> required <code>request</code> <code>Request</code> <p>Request to send.</p> required <p>Returns:</p> Type Description <code>Response</code> <p>Response from the request. Not guaranteed to be OK (status code &lt; 300).</p> Source code in <code>src/aiosalesforce/retries/policy.py</code> <pre><code>async def send_request_with_retries(\n    self,\n    httpx_client: AsyncClient,\n    event_bus: EventBus,\n    semaphore: asyncio.Semaphore,\n    request: Request,\n) -&gt; Response:\n    \"\"\"\n    Send a request and retry it if necessary in accordance with the retry policy.\n\n    Does not guarantee that the returned response is OK (status code &lt; 300),\n    only that the request was retried according to the policy.\n\n    Emits the following events:\\n\n    * RetryEvent if the request is retried\n    * RestApiCallConsumptionEvent for each request\n        that did not raise an exception\n\n    Parameters\n    ----------\n    httpx_client : AsyncClient\n        HTTP client to send the request.\n    event_bus : EventBus\n        Event bus to publish events.\n    semaphore : asyncio.Semaphore\n        Semaphore to limit the number of simultaneous requests.\n    request : Request\n        Request to send.\n\n    Returns\n    -------\n    Response\n        Response from the request.\n        Not guaranteed to be OK (status code &lt; 300).\n\n    \"\"\"\n    while True:\n        try:\n            async with semaphore:\n                response = await httpx_client.send(request)\n        except Exception as exc:\n            if await self.should_retry(exc):\n                await asyncio.gather(\n                    self.sleep(),\n                    event_bus.publish_event(\n                        RetryEvent(\n                            type=\"retry\",\n                            attempt=self.retry_count[\"total\"],\n                            request=request,\n                            exception=exc,\n                        )\n                    ),\n                )\n                continue\n            raise\n        await event_bus.publish_event(\n            RestApiCallConsumptionEvent(\n                type=\"rest_api_call_consumption\",\n                response=response,\n                count=1,\n            )\n        )\n        if not response.is_success and await self.should_retry(response):\n            await asyncio.gather(\n                self.sleep(),\n                event_bus.publish_event(\n                    RetryEvent(\n                        type=\"retry\",\n                        attempt=self.retry_count[\"total\"],\n                        request=request,\n                        response=response,\n                    )\n                ),\n            )\n            continue\n        return response\n</code></pre>"},{"location":"api-reference/retries/#aiosalesforce.retries.policy.RetryContext.should_retry","title":"<code>should_retry(value)</code>  <code>async</code>","text":"<p>Determine if the request should be retried.</p> <p>If the request should be retried, the total retry count and the retry count for the rule responsible for the retry are incremented.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Response | Exception</code> <p>Response or Exception from the request.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the request should be retried, False otherwise.</p> Source code in <code>src/aiosalesforce/retries/policy.py</code> <pre><code>async def should_retry(self, value: Response | Exception) -&gt; bool:\n    \"\"\"\n    Determine if the request should be retried.\n\n    If the request should be retried, the total retry count and the retry count\n    for the rule responsible for the retry are incremented.\n\n    Parameters\n    ----------\n    value : Response | Exception\n        Response or Exception from the request.\n\n    Returns\n    -------\n    bool\n        True if the request should be retried, False otherwise.\n\n    \"\"\"\n    if (\n        self.retry_count[\"total\"] &gt;= self.max_retries\n        or time.time() - self.start &gt; self.timeout\n    ):\n        return False\n    condition: bool = False\n    match value:\n        case Response():\n            condition = await self.__evaluate_response_rules(value)\n        case Exception():\n            condition = await self.__evaluate_exception_rules(value)\n        case _:  # pragma: no cover\n            raise TypeError(\"Value must be a Response or an Exception\")\n    if condition:\n        self.retry_count[\"total\"] += 1\n    return condition\n</code></pre>"},{"location":"api-reference/retries/#aiosalesforce.retries.policy.RetryContext.sleep","title":"<code>sleep()</code>  <code>async</code>","text":"<p>Sleep between retries based on the backoff policy.</p> Source code in <code>src/aiosalesforce/retries/policy.py</code> <pre><code>async def sleep(self) -&gt; None:\n    \"\"\"Sleep between retries based on the backoff policy.\"\"\"\n    # (total - 1) because this is called after incrementing the total count\n    sleep_time = min(\n        self.backoff_base\n        * (self.backoff_factor ** (self.retry_count[\"total\"] - 1)),\n        self.backoff_max,\n    )\n    if self.backoff_jitter:\n        sleep_time = random.uniform(0, sleep_time)  # noqa: S311\n    await asyncio.sleep(sleep_time)\n</code></pre>"},{"location":"api-reference/sobject/","title":"Sobject Client","text":""},{"location":"api-reference/sobject/#aiosalesforce.sobject.SobjectClient","title":"<code>SobjectClient</code>","text":"<p>Salesforce REST API sObject client.</p> <p>Parameters:</p> Name Type Description Default <code>salesforce_client</code> <code>Salesforce</code> <p>Salesforce client.</p> required Source code in <code>src/aiosalesforce/sobject.py</code> <pre><code>class SobjectClient:\n    \"\"\"\n    Salesforce REST API sObject client.\n\n    Parameters\n    ----------\n    salesforce_client : Salesforce\n        Salesforce client.\n\n    \"\"\"\n\n    salesforce_client: \"Salesforce\"\n    base_url: str\n    \"\"\"Base URL in the format https://[subdomain(s)].my.salesforce.com/services/data/v[version]/sobjects\"\"\"\n\n    def __init__(self, salesforce_client: \"Salesforce\") -&gt; None:\n        self.salesforce_client = salesforce_client\n        self.base_url = \"/\".join(\n            [\n                self.salesforce_client.base_url,\n                \"services\",\n                \"data\",\n                f\"v{self.salesforce_client.version}\",\n                \"sobjects\",\n            ]\n        )\n\n    async def create(\n        self,\n        sobject: str,\n        /,\n        data: dict | str | bytes | bytearray,\n    ) -&gt; str:\n        \"\"\"\n        Create a new record.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n            E.g. \"Account\", \"Contact\", etc.\n        data : dict | str | bytes | bytearray\n            Data to create the record with.\n            Either a dict or a JSON string/bytes representing a dict.\n\n        Returns\n        -------\n        str\n            ID of the created record.\n\n        \"\"\"\n        response = await self.salesforce_client.request(\n            \"POST\",\n            f\"{self.base_url}/{sobject}\",\n            content=json_dumps(data),\n            headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n        )\n        return json_loads(response.content)[\"id\"]\n\n    async def get(\n        self,\n        sobject: str,\n        id_: str,\n        /,\n        external_id_field: str | None = None,\n        fields: Iterable[str] | None = None,\n    ) -&gt; dict:\n        \"\"\"\n        Get record by ID or external ID.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n            E.g. \"Account\", \"Contact\", etc.\n        id_ : str\n            Salesforce record ID or external ID (if external_id_field is provided).\n        external_id_field : str, optional\n            External ID field name, by default None.\n        fields : Iterable[str], optional\n            Fields to get for the record.\n            By default returns all fields.\n\n        Returns\n        -------\n        dict\n            sObject data.\n\n        \"\"\"\n        url = httpx.URL(\n            \"/\".join(\n                [\n                    self.base_url,\n                    sobject,\n                    id_ if external_id_field is None else f\"{external_id_field}/{id_}\",\n                ]\n            )\n        )\n        if fields is not None:\n            url = url.copy_add_param(\"fields\", \",\".join(fields))\n        response = await self.salesforce_client.request(\n            \"GET\",\n            url,\n            headers={\"Accept\": \"application/json\"},\n        )\n        return json_loads(response.content)\n\n    async def update(\n        self,\n        sobject: str,\n        id_: str,\n        /,\n        data: dict | str | bytes | bytearray,\n    ) -&gt; None:\n        \"\"\"\n        Update record by ID.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n            E.g. \"Account\", \"Contact\", etc.\n        id_ : str\n            Salesforce record ID.\n        data : dict | str | bytes | bytearray\n            Data to update the record with.\n            Either a dict or a JSON string/bytes representing a dict.\n\n        \"\"\"\n        await self.salesforce_client.request(\n            \"PATCH\",\n            f\"{self.base_url}/{sobject}/{id_}\",\n            content=json_dumps(data),\n            headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n        )\n\n    async def delete(\n        self,\n        sobject: str,\n        id_: str,\n        /,\n        external_id_field: str | None = None,\n    ) -&gt; None:\n        \"\"\"\n        Delete record by ID.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n            E.g. \"Account\", \"Contact\", etc.\n        id_ : str\n            Salesforce record ID or external ID (if external_id_field is provided).\n        external_id_field : str, optional\n            External ID field name.\n            If not provided, id_ is treated as a record ID.\n\n        \"\"\"\n        await self.salesforce_client.request(\n            \"DELETE\",\n            \"/\".join(\n                [\n                    self.base_url,\n                    sobject,\n                    id_ if external_id_field is None else f\"{external_id_field}/{id_}\",\n                ]\n            ),\n        )\n\n    async def upsert(\n        self,\n        sobject: str,\n        id_: str,\n        /,\n        external_id_field: str,\n        data: dict | str | bytes | bytearray,\n        validate: bool = True,\n    ) -&gt; UpsertResponse:\n        \"\"\"\n        Upsert (update if exists, create if not) record by external ID.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n            E.g. \"Account\", \"Contact\", etc.\n        id_ : str\n            Salesforce record external ID.\n        external_id_field : str\n            External ID field name.\n        data : dict | str | bytes | bytearray\n            Data to upsert the record with.\n            Either a dict or a JSON string/bytes representing a dict.\n        validate : bool, default True\n            If True, validates the request and removes the external ID field\n            from the data if it's present. By default True.\n            The reason for this is that Salesforce does not allow\n            payload to contain an external ID field when upserting on it.\n            Set this to False if you know you data is correct and\n            you want to improve performance.\n\n        Returns\n        -------\n        UpsertResponse\n            Dataclass with 'id' and 'created' fields.\n\n        \"\"\"\n        if validate:\n            if isinstance(data, (str, bytes, bytearray)):\n                data = json_loads(data)\n            else:\n                # Copy payload to avoid mutating the original\n                data = json_loads(json_dumps(data))\n            if not isinstance(data, dict):\n                raise TypeError(\n                    f\"data must be a dict, str, bytes, or bytearray, \"\n                    f\"got {type(data).__name__}\"\n                )\n            try:\n                if str(data[external_id_field]) != str(id_):\n                    raise ValueError(\n                        f\"External ID field '{external_id_field}' in data \"\n                        f\"{data[external_id_field]} does not match \"\n                        f\"the provided external id '{id_}'\"\n                    )\n                data.pop(external_id_field)\n            except KeyError:\n                pass\n\n        response = await self.salesforce_client.request(\n            \"PATCH\",\n            f\"{self.base_url}/{sobject}/{external_id_field}/{id_}\",\n            content=json_dumps(data),\n            headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n        )\n        response_json = json_loads(response.content)\n        return UpsertResponse(\n            id=response_json[\"id\"],\n            created=response_json[\"created\"],\n        )\n</code></pre>"},{"location":"api-reference/sobject/#aiosalesforce.sobject.SobjectClient.base_url","title":"<code>base_url: str = '/'.join([self.salesforce_client.base_url, 'services', 'data', f'v{self.salesforce_client.version}', 'sobjects'])</code>  <code>instance-attribute</code>","text":"<p>Base URL in the format https://[subdomain(s)].my.salesforce.com/services/data/v[version]/sobjects</p>"},{"location":"api-reference/sobject/#aiosalesforce.sobject.SobjectClient.create","title":"<code>create(sobject, /, data)</code>  <code>async</code>","text":"<p>Create a new record.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name. E.g. \"Account\", \"Contact\", etc.</p> required <code>data</code> <code>dict | str | bytes | bytearray</code> <p>Data to create the record with. Either a dict or a JSON string/bytes representing a dict.</p> required <p>Returns:</p> Type Description <code>str</code> <p>ID of the created record.</p> Source code in <code>src/aiosalesforce/sobject.py</code> <pre><code>async def create(\n    self,\n    sobject: str,\n    /,\n    data: dict | str | bytes | bytearray,\n) -&gt; str:\n    \"\"\"\n    Create a new record.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n        E.g. \"Account\", \"Contact\", etc.\n    data : dict | str | bytes | bytearray\n        Data to create the record with.\n        Either a dict or a JSON string/bytes representing a dict.\n\n    Returns\n    -------\n    str\n        ID of the created record.\n\n    \"\"\"\n    response = await self.salesforce_client.request(\n        \"POST\",\n        f\"{self.base_url}/{sobject}\",\n        content=json_dumps(data),\n        headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n    )\n    return json_loads(response.content)[\"id\"]\n</code></pre>"},{"location":"api-reference/sobject/#aiosalesforce.sobject.SobjectClient.get","title":"<code>get(sobject, id_, /, external_id_field=None, fields=None)</code>  <code>async</code>","text":"<p>Get record by ID or external ID.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name. E.g. \"Account\", \"Contact\", etc.</p> required <code>id_</code> <code>str</code> <p>Salesforce record ID or external ID (if external_id_field is provided).</p> required <code>external_id_field</code> <code>str</code> <p>External ID field name, by default None.</p> <code>None</code> <code>fields</code> <code>Iterable[str]</code> <p>Fields to get for the record. By default returns all fields.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>sObject data.</p> Source code in <code>src/aiosalesforce/sobject.py</code> <pre><code>async def get(\n    self,\n    sobject: str,\n    id_: str,\n    /,\n    external_id_field: str | None = None,\n    fields: Iterable[str] | None = None,\n) -&gt; dict:\n    \"\"\"\n    Get record by ID or external ID.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n        E.g. \"Account\", \"Contact\", etc.\n    id_ : str\n        Salesforce record ID or external ID (if external_id_field is provided).\n    external_id_field : str, optional\n        External ID field name, by default None.\n    fields : Iterable[str], optional\n        Fields to get for the record.\n        By default returns all fields.\n\n    Returns\n    -------\n    dict\n        sObject data.\n\n    \"\"\"\n    url = httpx.URL(\n        \"/\".join(\n            [\n                self.base_url,\n                sobject,\n                id_ if external_id_field is None else f\"{external_id_field}/{id_}\",\n            ]\n        )\n    )\n    if fields is not None:\n        url = url.copy_add_param(\"fields\", \",\".join(fields))\n    response = await self.salesforce_client.request(\n        \"GET\",\n        url,\n        headers={\"Accept\": \"application/json\"},\n    )\n    return json_loads(response.content)\n</code></pre>"},{"location":"api-reference/sobject/#aiosalesforce.sobject.SobjectClient.update","title":"<code>update(sobject, id_, /, data)</code>  <code>async</code>","text":"<p>Update record by ID.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name. E.g. \"Account\", \"Contact\", etc.</p> required <code>id_</code> <code>str</code> <p>Salesforce record ID.</p> required <code>data</code> <code>dict | str | bytes | bytearray</code> <p>Data to update the record with. Either a dict or a JSON string/bytes representing a dict.</p> required Source code in <code>src/aiosalesforce/sobject.py</code> <pre><code>async def update(\n    self,\n    sobject: str,\n    id_: str,\n    /,\n    data: dict | str | bytes | bytearray,\n) -&gt; None:\n    \"\"\"\n    Update record by ID.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n        E.g. \"Account\", \"Contact\", etc.\n    id_ : str\n        Salesforce record ID.\n    data : dict | str | bytes | bytearray\n        Data to update the record with.\n        Either a dict or a JSON string/bytes representing a dict.\n\n    \"\"\"\n    await self.salesforce_client.request(\n        \"PATCH\",\n        f\"{self.base_url}/{sobject}/{id_}\",\n        content=json_dumps(data),\n        headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n    )\n</code></pre>"},{"location":"api-reference/sobject/#aiosalesforce.sobject.SobjectClient.delete","title":"<code>delete(sobject, id_, /, external_id_field=None)</code>  <code>async</code>","text":"<p>Delete record by ID.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name. E.g. \"Account\", \"Contact\", etc.</p> required <code>id_</code> <code>str</code> <p>Salesforce record ID or external ID (if external_id_field is provided).</p> required <code>external_id_field</code> <code>str</code> <p>External ID field name. If not provided, id_ is treated as a record ID.</p> <code>None</code> Source code in <code>src/aiosalesforce/sobject.py</code> <pre><code>async def delete(\n    self,\n    sobject: str,\n    id_: str,\n    /,\n    external_id_field: str | None = None,\n) -&gt; None:\n    \"\"\"\n    Delete record by ID.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n        E.g. \"Account\", \"Contact\", etc.\n    id_ : str\n        Salesforce record ID or external ID (if external_id_field is provided).\n    external_id_field : str, optional\n        External ID field name.\n        If not provided, id_ is treated as a record ID.\n\n    \"\"\"\n    await self.salesforce_client.request(\n        \"DELETE\",\n        \"/\".join(\n            [\n                self.base_url,\n                sobject,\n                id_ if external_id_field is None else f\"{external_id_field}/{id_}\",\n            ]\n        ),\n    )\n</code></pre>"},{"location":"api-reference/sobject/#aiosalesforce.sobject.SobjectClient.upsert","title":"<code>upsert(sobject, id_, /, external_id_field, data, validate=True)</code>  <code>async</code>","text":"<p>Upsert (update if exists, create if not) record by external ID.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name. E.g. \"Account\", \"Contact\", etc.</p> required <code>id_</code> <code>str</code> <p>Salesforce record external ID.</p> required <code>external_id_field</code> <code>str</code> <p>External ID field name.</p> required <code>data</code> <code>dict | str | bytes | bytearray</code> <p>Data to upsert the record with. Either a dict or a JSON string/bytes representing a dict.</p> required <code>validate</code> <code>bool</code> <p>If True, validates the request and removes the external ID field from the data if it's present. By default True. The reason for this is that Salesforce does not allow payload to contain an external ID field when upserting on it. Set this to False if you know you data is correct and you want to improve performance.</p> <code>True</code> <p>Returns:</p> Type Description <code>UpsertResponse</code> <p>Dataclass with 'id' and 'created' fields.</p> Source code in <code>src/aiosalesforce/sobject.py</code> <pre><code>async def upsert(\n    self,\n    sobject: str,\n    id_: str,\n    /,\n    external_id_field: str,\n    data: dict | str | bytes | bytearray,\n    validate: bool = True,\n) -&gt; UpsertResponse:\n    \"\"\"\n    Upsert (update if exists, create if not) record by external ID.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n        E.g. \"Account\", \"Contact\", etc.\n    id_ : str\n        Salesforce record external ID.\n    external_id_field : str\n        External ID field name.\n    data : dict | str | bytes | bytearray\n        Data to upsert the record with.\n        Either a dict or a JSON string/bytes representing a dict.\n    validate : bool, default True\n        If True, validates the request and removes the external ID field\n        from the data if it's present. By default True.\n        The reason for this is that Salesforce does not allow\n        payload to contain an external ID field when upserting on it.\n        Set this to False if you know you data is correct and\n        you want to improve performance.\n\n    Returns\n    -------\n    UpsertResponse\n        Dataclass with 'id' and 'created' fields.\n\n    \"\"\"\n    if validate:\n        if isinstance(data, (str, bytes, bytearray)):\n            data = json_loads(data)\n        else:\n            # Copy payload to avoid mutating the original\n            data = json_loads(json_dumps(data))\n        if not isinstance(data, dict):\n            raise TypeError(\n                f\"data must be a dict, str, bytes, or bytearray, \"\n                f\"got {type(data).__name__}\"\n            )\n        try:\n            if str(data[external_id_field]) != str(id_):\n                raise ValueError(\n                    f\"External ID field '{external_id_field}' in data \"\n                    f\"{data[external_id_field]} does not match \"\n                    f\"the provided external id '{id_}'\"\n                )\n            data.pop(external_id_field)\n        except KeyError:\n            pass\n\n    response = await self.salesforce_client.request(\n        \"PATCH\",\n        f\"{self.base_url}/{sobject}/{external_id_field}/{id_}\",\n        content=json_dumps(data),\n        headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n    )\n    response_json = json_loads(response.content)\n    return UpsertResponse(\n        id=response_json[\"id\"],\n        created=response_json[\"created\"],\n    )\n</code></pre>"},{"location":"api-reference/utils/","title":"Utilities","text":""},{"location":"api-reference/utils/#aiosalesforce.utils.json_dumps","title":"<code>json_dumps(data)</code>","text":"<p>Serialize data to a JSON formatted bytes object.</p> <p>Utility function used to allow users to pass an already serialized JSON.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | bytes | bytearray | Any</code> <p>Data to be serialized.</p> required <p>Returns:</p> Type Description <code>bytes</code> <p>JSON formatted bytes object.</p> Source code in <code>src/aiosalesforce/utils.py</code> <pre><code>def json_dumps(data: str | bytes | bytearray | Any) -&gt; bytes:\n    \"\"\"\n    Serialize data to a JSON formatted bytes object.\n\n    Utility function used to allow users to pass an already serialized JSON.\n\n    Parameters\n    ----------\n    data : str | bytes | bytearray | Any\n        Data to be serialized.\n\n    Returns\n    -------\n    bytes\n        JSON formatted bytes object.\n\n    \"\"\"\n    if isinstance(data, str):\n        return data.encode(\"utf-8\")\n    if isinstance(data, bytearray):\n        return bytes(data)\n    if isinstance(data, bytes):\n        return data\n    return orjson.dumps(data, option=orjson.OPT_OMIT_MICROSECONDS | orjson.OPT_UTC_Z)\n</code></pre>"},{"location":"api-reference/utils/#aiosalesforce.utils.json_loads","title":"<code>json_loads(data)</code>","text":"<p>Deserialize JSON formatted data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str | bytes | bytearray</code> <p>JSON formatted data.</p> required <p>Returns:</p> Type Description <code>Any</code> <p>Deserialized data.</p> Source code in <code>src/aiosalesforce/utils.py</code> <pre><code>def json_loads(data: str | bytes | bytearray) -&gt; Any:\n    \"\"\"\n    Deserialize JSON formatted data.\n\n    Parameters\n    ----------\n    data : str | bytes | bytearray\n        JSON formatted data.\n\n    Returns\n    -------\n    Any\n        Deserialized data.\n\n    \"\"\"\n    return orjson.loads(data)\n</code></pre>"},{"location":"api-reference/utils/#aiosalesforce.utils.format_soql","title":"<code>format_soql(query, *args, **kwargs)</code>","text":"<p>Format SOQL query template with dynamic parameters.</p> <p>While SOQL queries are safe by design (cannot create/update/delete records), it is still possible to expose sensitive information via SOQL injection. It is always recommended to use this function instead of string formatting.</p> <p>You should never surround your parameters with single quotes in the query template - this is done automatically by this function when necessary. E.g., \"SELECT Id FROM Object WHERE Value = {value}\"</p> <p>The only exception to this rule is when you use the 'like' format spec. The 'like' format spec is used to escape special characters in a LIKE pattern when a portion of it is dynamic. E.g., \"SELECT Id FROM Object WHERE Value LIKE '%{value:like}'\"</p> <p>If you don't use the 'like' format spec when formatting LIKE statements, you will get unnecessary quotes and special query characters (% and _) will not be escaped. This would make you vulnerable to SOQL injection.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; format_soql(\"SELECT Id FROM Account WHERE Name = {}\", \"John Doe\")\n\"SELECT Id FROM Account WHERE Name = 'John Doe'\"\n&gt;&gt;&gt; format_soql(\"SELECT Id FROM Account WHERE Name = {name}\", name=\"John Doe\")\n\"SELECT Id FROM Account WHERE Name = 'John Doe'\"\n&gt;&gt;&gt; format_soql(\"SELECT Id FROM Account WHERE Name LIKE {value}\", value=\"John%\")\n\"SELECT Id FROM Account WHERE Name LIKE 'John%'\"\n&gt;&gt;&gt; format_soql(\n&gt;&gt;&gt;     \"SELECT Id FROM Record WHERE Description LIKE '% fails {pattern:like}'\",\n&gt;&gt;&gt;     pattern=\"50% of the time\",\n&gt;&gt;&gt; )\n\"SELECT Id FROM Record WHERE Description LIKE '% fails 50\\% of the time'\"\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>LiteralString</code> <p>SOQL query template.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Formatted SOQL query.</p> Source code in <code>src/aiosalesforce/utils.py</code> <pre><code>def format_soql(query: LiteralString, *args, **kwargs) -&gt; str:\n    \"\"\"\n    Format SOQL query template with dynamic parameters.\n\n    While SOQL queries are safe by design (cannot create/update/delete records),\n    it is still possible to expose sensitive information via SOQL injection.\n    It is always recommended to use this function instead of string formatting.\n\n    You should never surround your parameters with single quotes in the query\n    template - this is done automatically by this function when necessary.\n    E.g., \"SELECT Id FROM Object WHERE Value = {value}\"\n\n    The only exception to this rule is when you use the 'like' format spec.\n    The 'like' format spec is used to escape special characters in a LIKE pattern\n    when a portion of it is dynamic.\n    E.g., \"SELECT Id FROM Object WHERE Value LIKE '%{value:like}'\"\n\n    If you don't use the 'like' format spec when formatting LIKE statements,\n    you will get unnecessary quotes and special query characters\n    (% and _) will not be escaped. This would make you vulnerable to SOQL injection.\n\n    Examples\n    --------\n    &gt;&gt;&gt; format_soql(\"SELECT Id FROM Account WHERE Name = {}\", \"John Doe\")\n    \"SELECT Id FROM Account WHERE Name = 'John Doe'\"\n    &gt;&gt;&gt; format_soql(\"SELECT Id FROM Account WHERE Name = {name}\", name=\"John Doe\")\n    \"SELECT Id FROM Account WHERE Name = 'John Doe'\"\n    &gt;&gt;&gt; format_soql(\"SELECT Id FROM Account WHERE Name LIKE {value}\", value=\"John%\")\n    \"SELECT Id FROM Account WHERE Name LIKE 'John%'\"\n    &gt;&gt;&gt; format_soql(\n    &gt;&gt;&gt;     \"SELECT Id FROM Record WHERE Description LIKE '% fails {pattern:like}'\",\n    &gt;&gt;&gt;     pattern=\"50% of the time\",\n    &gt;&gt;&gt; )\n    \"SELECT Id FROM Record WHERE Description LIKE '% fails 50\\\\% of the time'\"\n\n    Parameters\n    ----------\n    query : LiteralString\n        SOQL query template.\n\n    Returns\n    -------\n    str\n        Formatted SOQL query.\n\n    \"\"\"\n    # Use vformat to avoid unnecessary args/kwargs unpacking\n    return SoqlFormatter().vformat(query, args, kwargs)\n</code></pre>"},{"location":"api-reference/bulk/v2/client/","title":"Client","text":""},{"location":"api-reference/bulk/v2/client/#aiosalesforce.bulk.v2.client.IngestResult","title":"<code>IngestResult</code>  <code>dataclass</code>","text":"<p>Bulk API 2.0 ingest operation result.</p> Source code in <code>src/aiosalesforce/bulk/v2/client.py</code> <pre><code>@dataclasses.dataclass\nclass IngestResult:\n    \"\"\"Bulk API 2.0 ingest operation result.\"\"\"\n\n    jobs: list[JobInfo]\n    successful_results: list[dict[str, str]]\n    failed_results: list[dict[str, str]]\n    unprocessed_records: list[dict[str, str]]\n</code></pre>"},{"location":"api-reference/bulk/v2/client/#aiosalesforce.bulk.v2.client.BulkClientV2","title":"<code>BulkClientV2</code>","text":"<p>Salesforce Bulk API 2.0 client.</p> <p>Use this client to execute bulk ingest and query operations.</p> <p>Parameters:</p> Name Type Description Default <code>salesforce_client</code> <code>Salesforce</code> <p>Salesforce client.</p> required Source code in <code>src/aiosalesforce/bulk/v2/client.py</code> <pre><code>class BulkClientV2:\n    \"\"\"\n    Salesforce Bulk API 2.0 client.\n\n    Use this client to execute bulk ingest and query operations.\n\n    Parameters\n    ----------\n    salesforce_client : Salesforce\n        Salesforce client.\n\n    \"\"\"\n\n    salesforce_client: \"Salesforce\"\n    base_url: str\n    \"\"\"Base URL in the format https://[subdomain(s)].my.salesforce.com/services/data/v[version]/jobs\"\"\"\n\n    def __init__(self, salesforce_client: \"Salesforce\") -&gt; None:\n        self.salesforce_client = salesforce_client\n        self.base_url = \"/\".join(\n            [\n                self.salesforce_client.base_url,\n                \"services\",\n                \"data\",\n                f\"v{self.salesforce_client.version}\",\n                \"jobs\",\n            ]\n        )\n\n    @cached_property\n    def ingest(self) -&gt; BulkIngestClient:\n        \"\"\"Manage ingest jobs at a low level.\"\"\"\n        return BulkIngestClient(self)\n\n    async def __perform_operation(\n        self,\n        operation: OperationType,\n        sobject: str,\n        data: Iterable[dict[str, Any]],\n        external_id_field: str | None = None,\n        assignment_rule_id: str | None = None,\n    ) -&gt; IngestResult:\n        result = IngestResult([], [], [], [])\n        async for job_result in self.ingest.perform_operation(\n            operation=operation,\n            sobject=sobject,\n            data=data,\n            external_id_field=external_id_field,\n            assignment_rule_id=assignment_rule_id,\n        ):\n            result.jobs.append(job_result.job_info)\n            result.successful_results.extend(job_result.successful_results)\n            result.failed_results.extend(job_result.failed_results)\n            result.unprocessed_records.extend(job_result.unprocessed_records)\n        return result\n\n    async def insert(\n        self,\n        sobject: str,\n        data: Iterable[dict[str, Any]],\n        assignment_rule_id: str | None = None,\n    ) -&gt; IngestResult:\n        \"\"\"\n        Create new records in Salesforce.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n        data : Iterable[dict[str, Any]]\n            Records to create.\n        assignment_rule_id : str | None, default None\n            The ID of an assignment rule to run for a Case or a Lead.\n\n        Returns\n        -------\n        IngestResult\n            Bulk API 2.0 ingest job results.\n\n        \"\"\"\n        return await self.__perform_operation(\n            \"insert\",\n            sobject=sobject,\n            data=data,\n            assignment_rule_id=assignment_rule_id,\n        )\n\n    async def update(\n        self,\n        sobject: str,\n        data: Iterable[dict[str, Any]],\n        assignment_rule_id: str | None = None,\n    ) -&gt; IngestResult:\n        \"\"\"\n        Update existing records in Salesforce.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n        data : Iterable[dict[str, Any]]\n            Records to update.\n        assignment_rule_id : str | None, default None\n            The ID of an assignment rule to run for a Case or a Lead.\n\n        Returns\n        -------\n        IngestResult\n            Bulk API 2.0 ingest job results.\n\n        \"\"\"\n        return await self.__perform_operation(\n            \"update\",\n            sobject=sobject,\n            data=data,\n            assignment_rule_id=assignment_rule_id,\n        )\n\n    async def upsert(\n        self,\n        sobject: str,\n        data: Iterable[dict[str, Any]],\n        external_id_field: str,\n        assignment_rule_id: str | None = None,\n    ) -&gt; IngestResult:\n        \"\"\"\n        Create or update records in Salesforce.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n        data : Iterable[dict[str, Any]]\n            Records to create or update.\n        external_id_field : str\n            External ID field name.\n        assignment_rule_id : str | None, default None\n            The ID of an assignment rule to run for a Case or a Lead.\n\n        Returns\n        -------\n        IngestResult\n            Bulk API 2.0 ingest job results.\n\n        \"\"\"\n        return await self.__perform_operation(\n            \"upsert\",\n            sobject=sobject,\n            data=data,\n            external_id_field=external_id_field,\n            assignment_rule_id=assignment_rule_id,\n        )\n\n    async def delete(\n        self,\n        sobject: str,\n        data: Iterable[dict[str, Any]],\n        hard: bool = False,\n    ) -&gt; IngestResult:\n        \"\"\"\n        Delete records from Salesforce.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n        data : Iterable[dict[str, Any]]\n            Records to delete.\n        hard : bool, default False\n            Whether to hard delete records.\n\n        Returns\n        -------\n        IngestResult\n            Bulk API 2.0 ingest job results.\n\n        \"\"\"\n        return await self.__perform_operation(\n            \"hardDelete\" if hard else \"delete\",\n            sobject=sobject,\n            data=data,\n            assignment_rule_id=None,\n        )\n</code></pre>"},{"location":"api-reference/bulk/v2/client/#aiosalesforce.bulk.v2.client.BulkClientV2.base_url","title":"<code>base_url: str = '/'.join([self.salesforce_client.base_url, 'services', 'data', f'v{self.salesforce_client.version}', 'jobs'])</code>  <code>instance-attribute</code>","text":"<p>Base URL in the format https://[subdomain(s)].my.salesforce.com/services/data/v[version]/jobs</p>"},{"location":"api-reference/bulk/v2/client/#aiosalesforce.bulk.v2.client.BulkClientV2.ingest","title":"<code>ingest: BulkIngestClient</code>  <code>cached</code> <code>property</code>","text":"<p>Manage ingest jobs at a low level.</p>"},{"location":"api-reference/bulk/v2/client/#aiosalesforce.bulk.v2.client.BulkClientV2.insert","title":"<code>insert(sobject, data, assignment_rule_id=None)</code>  <code>async</code>","text":"<p>Create new records in Salesforce.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name.</p> required <code>data</code> <code>Iterable[dict[str, Any]]</code> <p>Records to create.</p> required <code>assignment_rule_id</code> <code>str | None</code> <p>The ID of an assignment rule to run for a Case or a Lead.</p> <code>None</code> <p>Returns:</p> Type Description <code>IngestResult</code> <p>Bulk API 2.0 ingest job results.</p> Source code in <code>src/aiosalesforce/bulk/v2/client.py</code> <pre><code>async def insert(\n    self,\n    sobject: str,\n    data: Iterable[dict[str, Any]],\n    assignment_rule_id: str | None = None,\n) -&gt; IngestResult:\n    \"\"\"\n    Create new records in Salesforce.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n    data : Iterable[dict[str, Any]]\n        Records to create.\n    assignment_rule_id : str | None, default None\n        The ID of an assignment rule to run for a Case or a Lead.\n\n    Returns\n    -------\n    IngestResult\n        Bulk API 2.0 ingest job results.\n\n    \"\"\"\n    return await self.__perform_operation(\n        \"insert\",\n        sobject=sobject,\n        data=data,\n        assignment_rule_id=assignment_rule_id,\n    )\n</code></pre>"},{"location":"api-reference/bulk/v2/client/#aiosalesforce.bulk.v2.client.BulkClientV2.update","title":"<code>update(sobject, data, assignment_rule_id=None)</code>  <code>async</code>","text":"<p>Update existing records in Salesforce.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name.</p> required <code>data</code> <code>Iterable[dict[str, Any]]</code> <p>Records to update.</p> required <code>assignment_rule_id</code> <code>str | None</code> <p>The ID of an assignment rule to run for a Case or a Lead.</p> <code>None</code> <p>Returns:</p> Type Description <code>IngestResult</code> <p>Bulk API 2.0 ingest job results.</p> Source code in <code>src/aiosalesforce/bulk/v2/client.py</code> <pre><code>async def update(\n    self,\n    sobject: str,\n    data: Iterable[dict[str, Any]],\n    assignment_rule_id: str | None = None,\n) -&gt; IngestResult:\n    \"\"\"\n    Update existing records in Salesforce.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n    data : Iterable[dict[str, Any]]\n        Records to update.\n    assignment_rule_id : str | None, default None\n        The ID of an assignment rule to run for a Case or a Lead.\n\n    Returns\n    -------\n    IngestResult\n        Bulk API 2.0 ingest job results.\n\n    \"\"\"\n    return await self.__perform_operation(\n        \"update\",\n        sobject=sobject,\n        data=data,\n        assignment_rule_id=assignment_rule_id,\n    )\n</code></pre>"},{"location":"api-reference/bulk/v2/client/#aiosalesforce.bulk.v2.client.BulkClientV2.upsert","title":"<code>upsert(sobject, data, external_id_field, assignment_rule_id=None)</code>  <code>async</code>","text":"<p>Create or update records in Salesforce.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name.</p> required <code>data</code> <code>Iterable[dict[str, Any]]</code> <p>Records to create or update.</p> required <code>external_id_field</code> <code>str</code> <p>External ID field name.</p> required <code>assignment_rule_id</code> <code>str | None</code> <p>The ID of an assignment rule to run for a Case or a Lead.</p> <code>None</code> <p>Returns:</p> Type Description <code>IngestResult</code> <p>Bulk API 2.0 ingest job results.</p> Source code in <code>src/aiosalesforce/bulk/v2/client.py</code> <pre><code>async def upsert(\n    self,\n    sobject: str,\n    data: Iterable[dict[str, Any]],\n    external_id_field: str,\n    assignment_rule_id: str | None = None,\n) -&gt; IngestResult:\n    \"\"\"\n    Create or update records in Salesforce.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n    data : Iterable[dict[str, Any]]\n        Records to create or update.\n    external_id_field : str\n        External ID field name.\n    assignment_rule_id : str | None, default None\n        The ID of an assignment rule to run for a Case or a Lead.\n\n    Returns\n    -------\n    IngestResult\n        Bulk API 2.0 ingest job results.\n\n    \"\"\"\n    return await self.__perform_operation(\n        \"upsert\",\n        sobject=sobject,\n        data=data,\n        external_id_field=external_id_field,\n        assignment_rule_id=assignment_rule_id,\n    )\n</code></pre>"},{"location":"api-reference/bulk/v2/client/#aiosalesforce.bulk.v2.client.BulkClientV2.delete","title":"<code>delete(sobject, data, hard=False)</code>  <code>async</code>","text":"<p>Delete records from Salesforce.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name.</p> required <code>data</code> <code>Iterable[dict[str, Any]]</code> <p>Records to delete.</p> required <code>hard</code> <code>bool</code> <p>Whether to hard delete records.</p> <code>False</code> <p>Returns:</p> Type Description <code>IngestResult</code> <p>Bulk API 2.0 ingest job results.</p> Source code in <code>src/aiosalesforce/bulk/v2/client.py</code> <pre><code>async def delete(\n    self,\n    sobject: str,\n    data: Iterable[dict[str, Any]],\n    hard: bool = False,\n) -&gt; IngestResult:\n    \"\"\"\n    Delete records from Salesforce.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n    data : Iterable[dict[str, Any]]\n        Records to delete.\n    hard : bool, default False\n        Whether to hard delete records.\n\n    Returns\n    -------\n    IngestResult\n        Bulk API 2.0 ingest job results.\n\n    \"\"\"\n    return await self.__perform_operation(\n        \"hardDelete\" if hard else \"delete\",\n        sobject=sobject,\n        data=data,\n        assignment_rule_id=None,\n    )\n</code></pre>"},{"location":"api-reference/bulk/v2/csv/","title":"CSV","text":""},{"location":"api-reference/bulk/v2/csv/#aiosalesforce.bulk.v2._csv.serialize_ingest_data","title":"<code>serialize_ingest_data(data, fieldnames=None, max_size_bytes=100000000, max_records=150000000)</code>","text":"<p>Serialize data into CSV files for ingestion by Salesforce Bulk API 2.0.</p> <p>None or missing values are ignored by Salesforce. To set a field in Salesforce to NULL, use the string \"#N/A\". Relationships are represented as nested dictionaries, with exactly one key-value pair. E.g. {\"Account\": {\"Name\": \"Acme\"}} or {\"Custom_Field__r\": {\"External_Id__c\": \"123\"}.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Iterable[dict[str, Any]]</code> <p>Sequence of dictionaries, each representing a record.</p> required <code>fieldnames</code> <code>Collection[str]</code> <p>Field names, determines order of fields in the CSV file. By default field names are inferred from the records. This is slow, so if you know the field names in advance, it is recommended to provide them. If a record is missing a field, it will be written as an empty string. If a record has a field not in <code>fieldnames</code>, an error will be raised.</p> <code>None</code> <code>max_size_bytes</code> <code>int</code> <p>Maximum size of each CSV file in bytes. The default of 100MB is recommended by Salesforce recommends. This accounts for base64 encoding increases in size by up to 50%.</p> <code>100000000</code> <code>max_records</code> <code>int</code> <p>Maximum number of records in each CSV file. By default 150,000,000. This corresponds to the maximum number of records in a 24-hour period.</p> <code>150000000</code> <p>Yields:</p> Type Description <code>bytes</code> <p>CSV file as a byte string.</p> Source code in <code>src/aiosalesforce/bulk/v2/_csv.py</code> <pre><code>def serialize_ingest_data(\n    data: Iterable[dict[str, Any]],\n    fieldnames: Collection[str] | None = None,\n    max_size_bytes: int = 100_000_000,\n    max_records: int = 150_000_000,\n) -&gt; Iterable[bytes]:\n    \"\"\"\n    Serialize data into CSV files for ingestion by Salesforce Bulk API 2.0.\n\n    None or missing values are ignored by Salesforce.\n    To set a field in Salesforce to NULL, use the string \"#N/A\".\n    Relationships are represented as nested dictionaries,\n    with exactly one key-value pair. E.g. {\"Account\": {\"Name\": \"Acme\"}}\n    or {\"Custom_Field__r\": {\"External_Id__c\": \"123\"}.\n\n    Parameters\n    ----------\n    data : Iterable[dict[str, Any]]\n        Sequence of dictionaries, each representing a record.\n    fieldnames : Collection[str], optional\n        Field names, determines order of fields in the CSV file.\n        By default field names are inferred from the records. This is slow, so\n        if you know the field names in advance, it is recommended to provide them.\n        If a record is missing a field, it will be written as an empty string.\n        If a record has a field not in `fieldnames`, an error will be raised.\n    max_size_bytes : int, optional\n        Maximum size of each CSV file in bytes.\n        The default of 100MB is recommended by Salesforce recommends.\n        This accounts for base64 encoding increases in size by up to 50%.\n    max_records : int, optional\n        Maximum number of records in each CSV file. By default 150,000,000.\n        This corresponds to the maximum number of records in a 24-hour period.\n\n    Yields\n    ------\n    bytes\n        CSV file as a byte string.\n\n    \"\"\"\n    if fieldnames is None and inspect.isgenerator(data):\n        warnings.warn(\n            (\n                \"Passing a generator without providing fieldnames causes the \"\n                \"entire contents of the generator to be stored in memory \"\n                \"to infer fieldnames. This may result in high memory usage.\"\n            ),\n            UserWarning,\n        )\n\n    data = map(_serialize_dict, data)\n    if fieldnames is None:\n        data = list(data)\n        fieldnames = dict.fromkeys(itertools.chain.from_iterable(data)).keys()\n\n    buffer = CsvBuffer()\n    writer = csv.DictWriter(\n        buffer,\n        fieldnames=fieldnames,\n        lineterminator=\"\\n\",\n    )\n\n    carry_over: bytes | None = None\n    for row in data:\n        if buffer.size == 0:\n            writer.writeheader()\n            if carry_over is not None:\n                buffer.write(carry_over.decode(\"utf-8\"))\n                carry_over = None\n        writer.writerow(row)\n        # -1 to account for the header\n        if buffer.size &gt;= max_size_bytes or (buffer.n_rows - 1) &gt;= max_records:\n            if buffer.size &gt; max_size_bytes or (buffer.n_rows - 1) &gt; max_records:\n                carry_over = buffer.pop()\n            yield buffer.content\n            buffer.flush()\n\n    if buffer.size &gt; 0:\n        yield buffer.content\n</code></pre>"},{"location":"api-reference/bulk/v2/csv/#aiosalesforce.bulk.v2._csv.deserialize_ingest_results","title":"<code>deserialize_ingest_results(data)</code>","text":"<p>Deserialize Salesforce Bulk API 2.0 ingest results from CSV.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>bytes</code> <p>CSV file as a byte string.</p> required <p>Returns:</p> Type Description <code>list[dict[str, str]]</code> <p>List of records as dictionaries.</p> Source code in <code>src/aiosalesforce/bulk/v2/_csv.py</code> <pre><code>def deserialize_ingest_results(data: bytes) -&gt; list[dict[str, str]]:\n    \"\"\"\n    Deserialize Salesforce Bulk API 2.0 ingest results from CSV.\n\n    Parameters\n    ----------\n    data : bytes\n        CSV file as a byte string.\n\n    Returns\n    -------\n    list[dict[str, str]]\n        List of records as dictionaries.\n\n    \"\"\"\n    reader = csv.DictReader(data.decode(\"utf-8\").splitlines())\n    return list(reader)\n</code></pre>"},{"location":"api-reference/bulk/v2/ingest/","title":"Ingest Client","text":""},{"location":"api-reference/bulk/v2/ingest/#aiosalesforce.bulk.v2.ingest.JobInfo","title":"<code>JobInfo</code>  <code>dataclass</code>","text":"<p>Bulk API 2.0 ingest job information.</p> Source code in <code>src/aiosalesforce/bulk/v2/ingest.py</code> <pre><code>@dataclasses.dataclass\nclass JobInfo:\n    \"\"\"Bulk API 2.0 ingest job information.\"\"\"\n\n    id: str\n    operation: str\n    object: str\n    created_by_id: str\n    created_date: datetime.datetime\n    system_modstamp: datetime.datetime\n    state: Literal[\n        \"Open\",\n        \"UploadComplete\",\n        \"InProgress\",\n        \"JobComplete\",\n        \"Aborted\",\n        \"Failed\",\n    ]\n    external_id_field_name: str | None\n    concurrency_mode: Literal[\"Parallel\"]\n    content_type: Literal[\"CSV\"]\n    api_version: str\n    job_type: Literal[\"V2Ingest\"] | None\n    content_url: str\n    line_ending: Literal[\"LF\", \"CRLF\"]\n    column_delimiter: Literal[\n        \"BACKQUOTE\",\n        \"CARET\",\n        \"COMMA\",\n        \"PIPE\",\n        \"SEMICOLON\",\n        \"TAB\",\n    ]\n\n    @classmethod\n    def from_json(cls, data: bytes) -&gt; Self:\n        job_info = cls(\n            **{\n                field.name: (_ := json_loads(data)).get(\n                    \"\".join(\n                        [\n                            component.capitalize() if i &gt; 0 else component\n                            for i, component in enumerate(field.name.split(\"_\"))\n                        ]\n                    ),\n                    None,\n                )\n                for field in dataclasses.fields(cls)\n            }\n        )\n        for attr in [\"created_date\", \"system_modstamp\"]:\n            setattr(\n                job_info,\n                attr,\n                datetime.datetime.fromisoformat(getattr(job_info, attr)),\n            )\n        return job_info\n</code></pre>"},{"location":"api-reference/bulk/v2/ingest/#aiosalesforce.bulk.v2.ingest.JobResult","title":"<code>JobResult</code>  <code>dataclass</code>","text":"<p>Bulk API 2.0 ingest job result.</p> Source code in <code>src/aiosalesforce/bulk/v2/ingest.py</code> <pre><code>@dataclasses.dataclass\nclass JobResult:\n    \"\"\"Bulk API 2.0 ingest job result.\"\"\"\n\n    job_info: JobInfo\n    successful_results: list[dict[str, str]]\n    failed_results: list[dict[str, str]]\n    unprocessed_records: list[dict[str, str]]\n</code></pre>"},{"location":"api-reference/bulk/v2/ingest/#aiosalesforce.bulk.v2.ingest.BulkIngestClient","title":"<code>BulkIngestClient</code>","text":"<p>Salesforce Bulk API 2.0 ingest client.</p> <p>This is a low-level client used to manage ingest jobs.</p> <p>Parameters:</p> Name Type Description Default <code>bulk_client</code> <code>BulkClientV2</code> <p>Bulk API 2.0 client from this client is invoked.</p> required Source code in <code>src/aiosalesforce/bulk/v2/ingest.py</code> <pre><code>class BulkIngestClient:\n    \"\"\"\n    Salesforce Bulk API 2.0 ingest client.\n\n    This is a low-level client used to manage ingest jobs.\n\n    Parameters\n    ----------\n    bulk_client : BulkClientV2\n        Bulk API 2.0 client from this client is invoked.\n\n    \"\"\"\n\n    bulk_client: \"BulkClientV2\"\n    base_url: str\n    \"\"\"Base URL in the format https://[subdomain(s)].my.salesforce.com/services/data/v[version]/jobs/ingest\"\"\"\n\n    def __init__(self, bulk_client: \"BulkClientV2\") -&gt; None:\n        self.bulk_client = bulk_client\n        self.base_url = f\"{self.bulk_client.base_url}/ingest\"\n\n    async def create_job(\n        self,\n        operation: OperationType,\n        sobject: str,\n        external_id_field: str | None = None,\n        assignment_rule_id: str | None = None,\n    ) -&gt; JobInfo:\n        \"\"\"\n        Create a new ingest job.\n\n        Parameters\n        ----------\n        operation : {\"insert\", \"delete\", \"hardDelete\", \"update\", \"upsert\"}\n            Operation to perform.\n        sobject : str\n            Salesforce object name.\n        external_id_field : str | None, optional\n            External ID field name, by default None.\n            Used for upsert operations.\n        assignment_rule_id : str | None, optional\n            The ID of an assignment rule to run for a Case or a Lead.\n            By default None.\n\n        Returns\n        -------\n        JobInfo\n            _description_\n        \"\"\"\n        payload: dict[str, str] = {\n            \"columnDelimiter\": \"COMMA\",\n            \"contentType\": \"CSV\",\n            \"lineEnding\": \"LF\",\n            \"object\": sobject,\n            \"operation\": operation,\n        }\n        if assignment_rule_id is not None:\n            payload[\"assignmentRuleId\"] = assignment_rule_id\n        if external_id_field is not None:\n            payload[\"externalIdFieldName\"] = external_id_field\n        response = await self.bulk_client.salesforce_client.request(\n            \"POST\",\n            self.base_url,\n            content=json_dumps(payload),\n            headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n        )\n        return JobInfo.from_json(response.content)\n\n    async def get_job(self, job_id: str) -&gt; JobInfo:\n        \"\"\"\n        Get information about ingest job.\n\n        Parameters\n        ----------\n        job_id : str\n            Ingest job ID.\n\n        Returns\n        -------\n        JobInfo\n            Job information.\n\n        \"\"\"\n        response = await self.bulk_client.salesforce_client.request(\n            \"GET\",\n            f\"{self.base_url}/{job_id}\",\n            headers={\"Accept\": \"application/json\"},\n        )\n        return JobInfo.from_json(response.content)\n\n    async def list_jobs(\n        self,\n        is_pk_chunking_enabled: bool | None = None,\n    ) -&gt; AsyncIterator[JobInfo]:\n        \"\"\"\n        List all ingest jobs.\n\n        Parameters\n        ----------\n        is_pk_chunking_enabled : bool | None, optional\n            Filter by primary key chunking enabled, by default None.\n\n        Yields\n        ------\n        JobInfo\n            Job information.\n\n        \"\"\"\n        params: dict[str, bool] | None = None\n        if is_pk_chunking_enabled is not None:\n            params = {\"isPkChunkingEnabled\": is_pk_chunking_enabled}\n\n        next_url: str | None = None\n        while True:\n            if next_url is None:\n                response = await self.bulk_client.salesforce_client.request(\n                    \"GET\",\n                    self.base_url,\n                    params=params,\n                    headers={\"Accept\": \"application/json\"},\n                )\n            else:\n                response = await self.bulk_client.salesforce_client.request(\n                    \"GET\",\n                    f\"{self.bulk_client.salesforce_client.base_url}{next_url}\",\n                    headers={\"Accept\": \"application/json\"},\n                )\n            response_json: dict = json_loads(response.content)\n            for record in response_json[\"records\"]:\n                yield JobInfo.from_json(json_dumps(record))\n            next_url = response_json.get(\"nextRecordsUrl\", None)\n            if next_url is None:\n                break\n\n    async def abort_job(self, job_id: str) -&gt; JobInfo:\n        \"\"\"\n        Abort ingest job.\n\n        Parameters\n        ----------\n        job_id : str\n            Ingest job ID.\n\n        Returns\n        -------\n        JobInfo\n            Job information.\n\n        \"\"\"\n        response = await self.bulk_client.salesforce_client.request(\n            \"PATCH\",\n            f\"{self.base_url}/{job_id}\",\n            content=json_dumps({\"state\": \"Aborted\"}),\n            headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n        )\n        return JobInfo.from_json(response.content)\n\n    async def delete_job(self, job_id: str) -&gt; None:\n        \"\"\"\n        Delete ingest job.\n\n        Parameters\n        ----------\n        job_id : str\n            Ingest job ID.\n\n        \"\"\"\n        await self.bulk_client.salesforce_client.request(\n            \"DELETE\",\n            f\"{self.base_url}/{job_id}\",\n        )\n\n    async def upload_job_data(\n        self,\n        job_id: str,\n        data: bytes,\n    ) -&gt; JobInfo:\n        \"\"\"\n        Upload data for an ingest job.\n\n        Job must be in the \"Open\" state.\n\n        Parameters\n        ----------\n        job_id : str\n            Ingest job ID.\n        data : bytes\n            CSV data to upload.\n\n        Returns\n        -------\n        JobInfo\n            Job information.\n\n        \"\"\"\n        await self.bulk_client.salesforce_client.request(\n            \"PUT\",\n            f\"{self.base_url}/{job_id}/batches\",\n            content=data,\n            headers={\"Content-Type\": \"text/csv\"},\n        )\n        response = await self.bulk_client.salesforce_client.request(\n            \"PATCH\",\n            f\"{self.base_url}/{job_id}\",\n            content=json_dumps({\"state\": \"UploadComplete\"}),\n            headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n        )\n        await self.bulk_client.salesforce_client.event_bus.publish_event(\n            BulkApiBatchConsumptionEvent(\n                type=\"bulk_api_batch_consumption\",\n                response=response,\n                # WARN Bulk API 2.0 does not provide a way to get the number of batches\n                #      consumed in a job. Number of batches is estimated based on the\n                #      Salesforce docs saying that a separate batch is created for every\n                #      10,000 records in data. First row is header and is not counted.\n                count=math.ceil((len(data.strip(b\"\\n\").split(b\"\\n\")) - 1) / 10_000),\n            )\n        )\n        return JobInfo.from_json(response.content)\n\n    async def __perform_operation(\n        self,\n        operation: OperationType,\n        sobject: str,\n        data: bytes,\n        external_id_field: str | None = None,\n        assignment_rule_id: str | None = None,\n        polling_interval: float = 5.0,\n    ) -&gt; JobResult:\n        job = await self.create_job(\n            operation,\n            sobject,\n            external_id_field=external_id_field,\n            assignment_rule_id=assignment_rule_id,\n        )\n        job = await self.upload_job_data(job.id, data)\n        while job.state.lower().strip(\" \") in {\"open\", \"uploadcomplete\", \"inprogress\"}:\n            await asyncio.sleep(polling_interval)\n            job = await self.get_job(job.id)\n\n        tasks: list[asyncio.Task[Response]] = []\n        async with asyncio.TaskGroup() as tg:\n            for type_ in [\n                \"successfulResults\",\n                \"failedResults\",\n                \"unprocessedrecords\",\n            ]:\n                tasks.append(\n                    tg.create_task(\n                        self.bulk_client.salesforce_client.request(\n                            \"GET\",\n                            f\"{self.base_url}/{job.id}/{type_}\",\n                        )\n                    )\n                )\n\n        return JobResult(\n            job_info=job,\n            successful_results=deserialize_ingest_results(\n                tasks[0].result().content,\n            ),\n            failed_results=deserialize_ingest_results(\n                tasks[1].result().content,\n            ),\n            unprocessed_records=deserialize_ingest_results(\n                tasks[2].result().content,\n            ),\n        )\n\n    async def perform_operation(\n        self,\n        operation: OperationType,\n        sobject: str,\n        data: Iterable[dict[str, Any]],\n        fieldnames: Collection[str] | None = None,\n        max_size_bytes: int = 100_000_000,\n        max_records: int = 150_000_000,\n        external_id_field: str | None = None,\n        assignment_rule_id: str | None = None,\n        polling_interval: float = 5.0,\n    ) -&gt; AsyncIterator[JobResult]:\n        \"\"\"\n        Perform a bulk ingest operation.\n\n        Parameters\n        ----------\n        operation : {\"insert\", \"delete\", \"hardDelete\", \"update\", \"upsert\"}\n            Operation to perform.\n        sobject : str\n            Salesforce object name.\n        data : Iterable[dict[str, Any]]\n            Sequence of records to ingest.\n        fieldnames : Collection[str], optional\n            Field names, determines order of fields in the CSV file.\n            By default field names are inferred from the records. This is slow, so\n            if you know the field names in advance, it is recommended to provide them.\n            If a record is missing a field, it will be written as an empty string.\n            If a record has a field not in `fieldnames`, an error will be raised.\n        max_size_bytes : int, optional\n            Maximum size of each CSV file in bytes.\n            The default of 100MB is recommended by Salesforce recommends.\n            This accounts for base64 encoding increases in size by up to 50%.\n        max_records : int, optional\n            Maximum number of records in each CSV file. By default 150,000,000.\n            This corresponds to the maximum number of records in a 24-hour period.\n        external_id_field : str | None, optional\n            External ID field name, by default None.\n            Used for upsert operations.\n        assignment_rule_id : str | None, optional\n            The ID of an assignment rule to run for a Case or a Lead.\n            By default None.\n        polling_interval : float, optional\n            Interval in seconds to poll the job status.\n            By default 5.0 seconds.\n\n        Yields\n        ------\n        JobResult\n            Job result containing job information and successful, failed,\n            and unprocessed records.\n\n        \"\"\"\n        tasks: list[asyncio.Task[JobResult]] = []\n        for csv_payload in serialize_ingest_data(\n            data,\n            fieldnames=fieldnames,\n            max_size_bytes=max_size_bytes,\n            max_records=max_records,\n        ):\n            tasks.append(\n                asyncio.create_task(\n                    self.__perform_operation(\n                        operation,\n                        sobject,\n                        csv_payload,\n                        external_id_field=external_id_field,\n                        assignment_rule_id=assignment_rule_id,\n                        polling_interval=polling_interval,\n                    )\n                )\n            )\n        for future in asyncio.as_completed(tasks):\n            yield await future\n</code></pre>"},{"location":"api-reference/bulk/v2/ingest/#aiosalesforce.bulk.v2.ingest.BulkIngestClient.base_url","title":"<code>base_url: str = f'{self.bulk_client.base_url}/ingest'</code>  <code>instance-attribute</code>","text":"<p>Base URL in the format https://[subdomain(s)].my.salesforce.com/services/data/v[version]/jobs/ingest</p>"},{"location":"api-reference/bulk/v2/ingest/#aiosalesforce.bulk.v2.ingest.BulkIngestClient.create_job","title":"<code>create_job(operation, sobject, external_id_field=None, assignment_rule_id=None)</code>  <code>async</code>","text":"<p>Create a new ingest job.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>(insert, delete, hardDelete, update, upsert)</code> <p>Operation to perform.</p> <code>\"insert\"</code> <code>sobject</code> <code>str</code> <p>Salesforce object name.</p> required <code>external_id_field</code> <code>str | None</code> <p>External ID field name, by default None. Used for upsert operations.</p> <code>None</code> <code>assignment_rule_id</code> <code>str | None</code> <p>The ID of an assignment rule to run for a Case or a Lead. By default None.</p> <code>None</code> <p>Returns:</p> Type Description <code>JobInfo</code> <p>description</p> Source code in <code>src/aiosalesforce/bulk/v2/ingest.py</code> <pre><code>async def create_job(\n    self,\n    operation: OperationType,\n    sobject: str,\n    external_id_field: str | None = None,\n    assignment_rule_id: str | None = None,\n) -&gt; JobInfo:\n    \"\"\"\n    Create a new ingest job.\n\n    Parameters\n    ----------\n    operation : {\"insert\", \"delete\", \"hardDelete\", \"update\", \"upsert\"}\n        Operation to perform.\n    sobject : str\n        Salesforce object name.\n    external_id_field : str | None, optional\n        External ID field name, by default None.\n        Used for upsert operations.\n    assignment_rule_id : str | None, optional\n        The ID of an assignment rule to run for a Case or a Lead.\n        By default None.\n\n    Returns\n    -------\n    JobInfo\n        _description_\n    \"\"\"\n    payload: dict[str, str] = {\n        \"columnDelimiter\": \"COMMA\",\n        \"contentType\": \"CSV\",\n        \"lineEnding\": \"LF\",\n        \"object\": sobject,\n        \"operation\": operation,\n    }\n    if assignment_rule_id is not None:\n        payload[\"assignmentRuleId\"] = assignment_rule_id\n    if external_id_field is not None:\n        payload[\"externalIdFieldName\"] = external_id_field\n    response = await self.bulk_client.salesforce_client.request(\n        \"POST\",\n        self.base_url,\n        content=json_dumps(payload),\n        headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n    )\n    return JobInfo.from_json(response.content)\n</code></pre>"},{"location":"api-reference/bulk/v2/ingest/#aiosalesforce.bulk.v2.ingest.BulkIngestClient.get_job","title":"<code>get_job(job_id)</code>  <code>async</code>","text":"<p>Get information about ingest job.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>str</code> <p>Ingest job ID.</p> required <p>Returns:</p> Type Description <code>JobInfo</code> <p>Job information.</p> Source code in <code>src/aiosalesforce/bulk/v2/ingest.py</code> <pre><code>async def get_job(self, job_id: str) -&gt; JobInfo:\n    \"\"\"\n    Get information about ingest job.\n\n    Parameters\n    ----------\n    job_id : str\n        Ingest job ID.\n\n    Returns\n    -------\n    JobInfo\n        Job information.\n\n    \"\"\"\n    response = await self.bulk_client.salesforce_client.request(\n        \"GET\",\n        f\"{self.base_url}/{job_id}\",\n        headers={\"Accept\": \"application/json\"},\n    )\n    return JobInfo.from_json(response.content)\n</code></pre>"},{"location":"api-reference/bulk/v2/ingest/#aiosalesforce.bulk.v2.ingest.BulkIngestClient.list_jobs","title":"<code>list_jobs(is_pk_chunking_enabled=None)</code>  <code>async</code>","text":"<p>List all ingest jobs.</p> <p>Parameters:</p> Name Type Description Default <code>is_pk_chunking_enabled</code> <code>bool | None</code> <p>Filter by primary key chunking enabled, by default None.</p> <code>None</code> <p>Yields:</p> Type Description <code>JobInfo</code> <p>Job information.</p> Source code in <code>src/aiosalesforce/bulk/v2/ingest.py</code> <pre><code>async def list_jobs(\n    self,\n    is_pk_chunking_enabled: bool | None = None,\n) -&gt; AsyncIterator[JobInfo]:\n    \"\"\"\n    List all ingest jobs.\n\n    Parameters\n    ----------\n    is_pk_chunking_enabled : bool | None, optional\n        Filter by primary key chunking enabled, by default None.\n\n    Yields\n    ------\n    JobInfo\n        Job information.\n\n    \"\"\"\n    params: dict[str, bool] | None = None\n    if is_pk_chunking_enabled is not None:\n        params = {\"isPkChunkingEnabled\": is_pk_chunking_enabled}\n\n    next_url: str | None = None\n    while True:\n        if next_url is None:\n            response = await self.bulk_client.salesforce_client.request(\n                \"GET\",\n                self.base_url,\n                params=params,\n                headers={\"Accept\": \"application/json\"},\n            )\n        else:\n            response = await self.bulk_client.salesforce_client.request(\n                \"GET\",\n                f\"{self.bulk_client.salesforce_client.base_url}{next_url}\",\n                headers={\"Accept\": \"application/json\"},\n            )\n        response_json: dict = json_loads(response.content)\n        for record in response_json[\"records\"]:\n            yield JobInfo.from_json(json_dumps(record))\n        next_url = response_json.get(\"nextRecordsUrl\", None)\n        if next_url is None:\n            break\n</code></pre>"},{"location":"api-reference/bulk/v2/ingest/#aiosalesforce.bulk.v2.ingest.BulkIngestClient.abort_job","title":"<code>abort_job(job_id)</code>  <code>async</code>","text":"<p>Abort ingest job.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>str</code> <p>Ingest job ID.</p> required <p>Returns:</p> Type Description <code>JobInfo</code> <p>Job information.</p> Source code in <code>src/aiosalesforce/bulk/v2/ingest.py</code> <pre><code>async def abort_job(self, job_id: str) -&gt; JobInfo:\n    \"\"\"\n    Abort ingest job.\n\n    Parameters\n    ----------\n    job_id : str\n        Ingest job ID.\n\n    Returns\n    -------\n    JobInfo\n        Job information.\n\n    \"\"\"\n    response = await self.bulk_client.salesforce_client.request(\n        \"PATCH\",\n        f\"{self.base_url}/{job_id}\",\n        content=json_dumps({\"state\": \"Aborted\"}),\n        headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n    )\n    return JobInfo.from_json(response.content)\n</code></pre>"},{"location":"api-reference/bulk/v2/ingest/#aiosalesforce.bulk.v2.ingest.BulkIngestClient.delete_job","title":"<code>delete_job(job_id)</code>  <code>async</code>","text":"<p>Delete ingest job.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>str</code> <p>Ingest job ID.</p> required Source code in <code>src/aiosalesforce/bulk/v2/ingest.py</code> <pre><code>async def delete_job(self, job_id: str) -&gt; None:\n    \"\"\"\n    Delete ingest job.\n\n    Parameters\n    ----------\n    job_id : str\n        Ingest job ID.\n\n    \"\"\"\n    await self.bulk_client.salesforce_client.request(\n        \"DELETE\",\n        f\"{self.base_url}/{job_id}\",\n    )\n</code></pre>"},{"location":"api-reference/bulk/v2/ingest/#aiosalesforce.bulk.v2.ingest.BulkIngestClient.upload_job_data","title":"<code>upload_job_data(job_id, data)</code>  <code>async</code>","text":"<p>Upload data for an ingest job.</p> <p>Job must be in the \"Open\" state.</p> <p>Parameters:</p> Name Type Description Default <code>job_id</code> <code>str</code> <p>Ingest job ID.</p> required <code>data</code> <code>bytes</code> <p>CSV data to upload.</p> required <p>Returns:</p> Type Description <code>JobInfo</code> <p>Job information.</p> Source code in <code>src/aiosalesforce/bulk/v2/ingest.py</code> <pre><code>async def upload_job_data(\n    self,\n    job_id: str,\n    data: bytes,\n) -&gt; JobInfo:\n    \"\"\"\n    Upload data for an ingest job.\n\n    Job must be in the \"Open\" state.\n\n    Parameters\n    ----------\n    job_id : str\n        Ingest job ID.\n    data : bytes\n        CSV data to upload.\n\n    Returns\n    -------\n    JobInfo\n        Job information.\n\n    \"\"\"\n    await self.bulk_client.salesforce_client.request(\n        \"PUT\",\n        f\"{self.base_url}/{job_id}/batches\",\n        content=data,\n        headers={\"Content-Type\": \"text/csv\"},\n    )\n    response = await self.bulk_client.salesforce_client.request(\n        \"PATCH\",\n        f\"{self.base_url}/{job_id}\",\n        content=json_dumps({\"state\": \"UploadComplete\"}),\n        headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n    )\n    await self.bulk_client.salesforce_client.event_bus.publish_event(\n        BulkApiBatchConsumptionEvent(\n            type=\"bulk_api_batch_consumption\",\n            response=response,\n            # WARN Bulk API 2.0 does not provide a way to get the number of batches\n            #      consumed in a job. Number of batches is estimated based on the\n            #      Salesforce docs saying that a separate batch is created for every\n            #      10,000 records in data. First row is header and is not counted.\n            count=math.ceil((len(data.strip(b\"\\n\").split(b\"\\n\")) - 1) / 10_000),\n        )\n    )\n    return JobInfo.from_json(response.content)\n</code></pre>"},{"location":"api-reference/bulk/v2/ingest/#aiosalesforce.bulk.v2.ingest.BulkIngestClient.perform_operation","title":"<code>perform_operation(operation, sobject, data, fieldnames=None, max_size_bytes=100000000, max_records=150000000, external_id_field=None, assignment_rule_id=None, polling_interval=5.0)</code>  <code>async</code>","text":"<p>Perform a bulk ingest operation.</p> <p>Parameters:</p> Name Type Description Default <code>operation</code> <code>(insert, delete, hardDelete, update, upsert)</code> <p>Operation to perform.</p> <code>\"insert\"</code> <code>sobject</code> <code>str</code> <p>Salesforce object name.</p> required <code>data</code> <code>Iterable[dict[str, Any]]</code> <p>Sequence of records to ingest.</p> required <code>fieldnames</code> <code>Collection[str]</code> <p>Field names, determines order of fields in the CSV file. By default field names are inferred from the records. This is slow, so if you know the field names in advance, it is recommended to provide them. If a record is missing a field, it will be written as an empty string. If a record has a field not in <code>fieldnames</code>, an error will be raised.</p> <code>None</code> <code>max_size_bytes</code> <code>int</code> <p>Maximum size of each CSV file in bytes. The default of 100MB is recommended by Salesforce recommends. This accounts for base64 encoding increases in size by up to 50%.</p> <code>100000000</code> <code>max_records</code> <code>int</code> <p>Maximum number of records in each CSV file. By default 150,000,000. This corresponds to the maximum number of records in a 24-hour period.</p> <code>150000000</code> <code>external_id_field</code> <code>str | None</code> <p>External ID field name, by default None. Used for upsert operations.</p> <code>None</code> <code>assignment_rule_id</code> <code>str | None</code> <p>The ID of an assignment rule to run for a Case or a Lead. By default None.</p> <code>None</code> <code>polling_interval</code> <code>float</code> <p>Interval in seconds to poll the job status. By default 5.0 seconds.</p> <code>5.0</code> <p>Yields:</p> Type Description <code>JobResult</code> <p>Job result containing job information and successful, failed, and unprocessed records.</p> Source code in <code>src/aiosalesforce/bulk/v2/ingest.py</code> <pre><code>async def perform_operation(\n    self,\n    operation: OperationType,\n    sobject: str,\n    data: Iterable[dict[str, Any]],\n    fieldnames: Collection[str] | None = None,\n    max_size_bytes: int = 100_000_000,\n    max_records: int = 150_000_000,\n    external_id_field: str | None = None,\n    assignment_rule_id: str | None = None,\n    polling_interval: float = 5.0,\n) -&gt; AsyncIterator[JobResult]:\n    \"\"\"\n    Perform a bulk ingest operation.\n\n    Parameters\n    ----------\n    operation : {\"insert\", \"delete\", \"hardDelete\", \"update\", \"upsert\"}\n        Operation to perform.\n    sobject : str\n        Salesforce object name.\n    data : Iterable[dict[str, Any]]\n        Sequence of records to ingest.\n    fieldnames : Collection[str], optional\n        Field names, determines order of fields in the CSV file.\n        By default field names are inferred from the records. This is slow, so\n        if you know the field names in advance, it is recommended to provide them.\n        If a record is missing a field, it will be written as an empty string.\n        If a record has a field not in `fieldnames`, an error will be raised.\n    max_size_bytes : int, optional\n        Maximum size of each CSV file in bytes.\n        The default of 100MB is recommended by Salesforce recommends.\n        This accounts for base64 encoding increases in size by up to 50%.\n    max_records : int, optional\n        Maximum number of records in each CSV file. By default 150,000,000.\n        This corresponds to the maximum number of records in a 24-hour period.\n    external_id_field : str | None, optional\n        External ID field name, by default None.\n        Used for upsert operations.\n    assignment_rule_id : str | None, optional\n        The ID of an assignment rule to run for a Case or a Lead.\n        By default None.\n    polling_interval : float, optional\n        Interval in seconds to poll the job status.\n        By default 5.0 seconds.\n\n    Yields\n    ------\n    JobResult\n        Job result containing job information and successful, failed,\n        and unprocessed records.\n\n    \"\"\"\n    tasks: list[asyncio.Task[JobResult]] = []\n    for csv_payload in serialize_ingest_data(\n        data,\n        fieldnames=fieldnames,\n        max_size_bytes=max_size_bytes,\n        max_records=max_records,\n    ):\n        tasks.append(\n            asyncio.create_task(\n                self.__perform_operation(\n                    operation,\n                    sobject,\n                    csv_payload,\n                    external_id_field=external_id_field,\n                    assignment_rule_id=assignment_rule_id,\n                    polling_interval=polling_interval,\n                )\n            )\n        )\n    for future in asyncio.as_completed(tasks):\n        yield await future\n</code></pre>"},{"location":"api-reference/composite/batch/","title":"Batch","text":""},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.Subrequest","title":"<code>Subrequest</code>","text":"<p>Composite Batch subrequest.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Literal['GET', 'POST', 'PUT', 'PATCH', 'DELETE']</code> <p>HTTP method.</p> required <code>url</code> <code>str</code> <p>Request URL.</p> required <code>rich_input</code> <code>dict</code> <p>Input body for the request.</p> <code>None</code> <code>binary_part_name</code> <code>str</code> <p>Name of the binary part in the multipart request.</p> <code>None</code> <code>binary_part_name_alias</code> <code>str</code> <p>The name parameter in the Content-Disposition header of the binary body part.</p> <code>None</code> Source code in <code>src/aiosalesforce/composite/batch.py</code> <pre><code>class Subrequest:\n    \"\"\"\n    Composite Batch subrequest.\n\n    Parameters\n    ----------\n    method : Literal[\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"]\n        HTTP method.\n    url : str\n        Request URL.\n    rich_input : dict, optional\n        Input body for the request.\n    binary_part_name : str, optional\n        Name of the binary part in the multipart request.\n    binary_part_name_alias : str, optional\n        The name parameter in the Content-Disposition header of the binary body part.\n\n    \"\"\"\n\n    method: Literal[\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"]\n    url: str\n    rich_input: dict | None\n    binary_part_name: str | None\n    binary_part_name_alias: str | None\n\n    __response: dict | None\n\n    def __init__(\n        self,\n        method: Literal[\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"],\n        url: str,\n        rich_input: dict | None = None,\n        binary_part_name: str | None = None,\n        binary_part_name_alias: str | None = None,\n    ) -&gt; None:\n        self.method = method\n        self.url = url\n        self.rich_input = rich_input\n        self.binary_part_name = binary_part_name\n        self.binary_part_name_alias = binary_part_name_alias\n\n        if (self.binary_part_name is None) ^ (self.binary_part_name_alias is None):\n            raise ValueError(\n                \"Both or neither of 'binary_part_name' and 'binary_part_name_alias' \"\n                \"must be provided.\"\n            )\n\n        self.__response = None\n\n    def to_dict(self) -&gt; dict:\n        payload = {\n            \"method\": self.method,\n            \"url\": self.url,\n            \"richInput\": self.rich_input,\n            \"binaryPartName\": self.binary_part_name,\n            \"binaryPartNameAlias\": self.binary_part_name_alias,\n        }\n        return {key: value for key, value in payload.items() if value is not None}\n\n    @property\n    def response(self) -&gt; dict:\n        \"\"\"Subrequest response.\"\"\"\n        if self.__response is None:\n            raise InvalidStateError(\"Subrequest response has not been set\")\n        return self.__response\n\n    @response.setter\n    def response(self, value: dict) -&gt; None:\n        self.__response = value\n\n    @property\n    def done(self) -&gt; bool:\n        \"\"\"Whether the subrequest has been executed.\"\"\"\n        return self.__response is not None\n\n    @property\n    def status_code(self) -&gt; int:\n        \"\"\"HTTP status code of the subrequest response.\"\"\"\n        return self.response[\"statusCode\"]\n\n    @property\n    def result(self) -&gt; dict | list | None:\n        \"\"\"Subrequest result (response body).\"\"\"\n        return self.response[\"result\"]\n\n    @property\n    def is_success(self) -&gt; bool:\n        \"\"\"Whether this subrequest was successful.\"\"\"\n        return 200 &lt;= self.status_code &lt; 300\n\n    def raise_for_status(self) -&gt; None:\n        \"\"\"Raise an exception if this subrequest failed.\"\"\"\n        if not self.is_success:\n            raise_salesforce_error(httpx.Response(self.status_code, json=self.result))\n</code></pre>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.Subrequest.response","title":"<code>response: dict</code>  <code>property</code> <code>writable</code>","text":"<p>Subrequest response.</p>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.Subrequest.done","title":"<code>done: bool</code>  <code>property</code>","text":"<p>Whether the subrequest has been executed.</p>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.Subrequest.status_code","title":"<code>status_code: int</code>  <code>property</code>","text":"<p>HTTP status code of the subrequest response.</p>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.Subrequest.result","title":"<code>result: dict | list | None</code>  <code>property</code>","text":"<p>Subrequest result (response body).</p>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.Subrequest.is_success","title":"<code>is_success: bool</code>  <code>property</code>","text":"<p>Whether this subrequest was successful.</p>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.Subrequest.raise_for_status","title":"<code>raise_for_status()</code>","text":"<p>Raise an exception if this subrequest failed.</p> Source code in <code>src/aiosalesforce/composite/batch.py</code> <pre><code>def raise_for_status(self) -&gt; None:\n    \"\"\"Raise an exception if this subrequest failed.\"\"\"\n    if not self.is_success:\n        raise_salesforce_error(httpx.Response(self.status_code, json=self.result))\n</code></pre>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.QuerySubrequest","title":"<code>QuerySubrequest</code>","text":"<p>             Bases: <code>Subrequest</code></p> <p>SOQL query subrequest.</p> Source code in <code>src/aiosalesforce/composite/batch.py</code> <pre><code>class QuerySubrequest(Subrequest):\n    \"\"\"SOQL query subrequest.\"\"\"\n\n    @property\n    def records(self) -&gt; list[dict]:\n        \"\"\"Query records.\"\"\"\n        self.raise_for_status()\n        assert isinstance(self.result, dict)\n        return self.result[\"records\"]\n</code></pre>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.QuerySubrequest.records","title":"<code>records: list[dict]</code>  <code>property</code>","text":"<p>Query records.</p>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.SobjectCreateSubrequest","title":"<code>SobjectCreateSubrequest</code>","text":"<p>             Bases: <code>Subrequest</code></p> <p>sObject create subrequest.</p> Source code in <code>src/aiosalesforce/composite/batch.py</code> <pre><code>class SobjectCreateSubrequest(Subrequest):\n    \"\"\"sObject create subrequest.\"\"\"\n\n    @property\n    def id(self) -&gt; str:\n        \"\"\"ID of the created record.\"\"\"\n        self.raise_for_status()\n        assert isinstance(self.result, dict)\n        return self.result[\"id\"]\n</code></pre>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.SobjectCreateSubrequest.id","title":"<code>id: str</code>  <code>property</code>","text":"<p>ID of the created record.</p>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.SobjectGetSubrequest","title":"<code>SobjectGetSubrequest</code>","text":"<p>             Bases: <code>Subrequest</code></p> <p>sObject get subrequest.</p> Source code in <code>src/aiosalesforce/composite/batch.py</code> <pre><code>class SobjectGetSubrequest(Subrequest):\n    \"\"\"sObject get subrequest.\"\"\"\n\n    @property\n    def record(self) -&gt; dict:\n        \"\"\"Retrieved record.\"\"\"\n        self.raise_for_status()\n        assert isinstance(self.result, dict)\n        return self.result\n</code></pre>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.SobjectGetSubrequest.record","title":"<code>record: dict</code>  <code>property</code>","text":"<p>Retrieved record.</p>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.SobjectUpsertSubrequest","title":"<code>SobjectUpsertSubrequest</code>","text":"<p>             Bases: <code>Subrequest</code></p> <p>sObject upsert subrequest.</p> Source code in <code>src/aiosalesforce/composite/batch.py</code> <pre><code>class SobjectUpsertSubrequest(Subrequest):\n    \"\"\"sObject upsert subrequest.\"\"\"\n\n    @property\n    def id(self) -&gt; str:\n        \"\"\"ID of the upserted record.\"\"\"\n        self.raise_for_status()\n        assert isinstance(self.result, dict)\n        return self.result[\"id\"]\n\n    @property\n    def created(self) -&gt; bool:\n        \"\"\"Whether the record was created.\"\"\"\n        self.raise_for_status()\n        assert isinstance(self.result, dict)\n        return self.result[\"created\"]\n</code></pre>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.SobjectUpsertSubrequest.id","title":"<code>id: str</code>  <code>property</code>","text":"<p>ID of the upserted record.</p>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.SobjectUpsertSubrequest.created","title":"<code>created: bool</code>  <code>property</code>","text":"<p>Whether the record was created.</p>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.SobjectSubrequestClient","title":"<code>SobjectSubrequestClient</code>","text":"<p>Client for sObject operations.</p> <p>Parameters:</p> Name Type Description Default <code>composite_batch_request</code> <code>CompositeBatchRequest</code> <p>Composite Batch request.</p> required Source code in <code>src/aiosalesforce/composite/batch.py</code> <pre><code>class SobjectSubrequestClient:\n    \"\"\"\n    Client for sObject operations.\n\n    Parameters\n    ----------\n    composite_batch_request : CompositeBatchRequest\n        Composite Batch request.\n\n    \"\"\"\n\n    composite_batch_request: \"CompositeBatchRequest\"\n    base_path: str\n    \"\"\"Base path in the format /services/data/v[version]/sobjects\"\"\"\n\n    def __init__(self, composite_batch_request: \"CompositeBatchRequest\") -&gt; None:\n        self.composite_batch_request = composite_batch_request\n        self.base_path = \"/\".join(\n            [\n                \"\",\n                \"services\",\n                \"data\",\n                f\"v{self.composite_batch_request.salesforce_client.version}\",\n                \"sobjects\",\n            ]\n        )\n\n    def create(\n        self,\n        sobject: str,\n        /,\n        data: dict | str | bytes | bytearray,\n    ) -&gt; SobjectCreateSubrequest:\n        \"\"\"\n        Create a new record.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n            E.g. \"Account\", \"Contact\", etc.\n        data : dict | str | bytes | bytearray\n            Data to create the record with.\n            Either a dict or a JSON string/bytes representing a dict.\n\n        Returns\n        -------\n        SobjectCreateSubrequest\n            Create subrequest.\n            Record ID can be accessed via the `id` property.\n\n        \"\"\"\n        subrequest = SobjectCreateSubrequest(\n            \"POST\",\n            f\"{self.base_path}/{sobject}\",\n            rich_input=data if isinstance(data, dict) else json_loads(data),\n        )\n        self.composite_batch_request.subrequests.append(subrequest)\n        return subrequest\n\n    def get(\n        self,\n        sobject: str,\n        id_: str,\n        /,\n        external_id_field: str | None = None,\n        fields: Iterable[str] | None = None,\n    ) -&gt; SobjectGetSubrequest:\n        \"\"\"\n        Get record by ID or external ID.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n            E.g. \"Account\", \"Contact\", etc.\n        id_ : str\n            Salesforce record ID or external ID (if external_id_field is provided).\n        external_id_field : str, optional\n            External ID field name, by default None.\n        fields : Iterable[str], optional\n            Fields to get for the record.\n            By default returns all fields.\n\n        Returns\n        -------\n        SobbjectGetSubrequest\n            Get subrequest.\n            Record can be accessed via the `record` property.\n\n        \"\"\"\n        url = httpx.URL(\n            \"/\".join(\n                [\n                    self.base_path,\n                    sobject,\n                    id_ if external_id_field is None else f\"{external_id_field}/{id_}\",\n                ]\n            )\n        )\n        if fields is not None:\n            url = url.copy_add_param(\"fields\", \",\".join(fields))\n        subrequest = SobjectGetSubrequest(\"GET\", str(url))\n        self.composite_batch_request.subrequests.append(subrequest)\n        return subrequest\n\n    def update(\n        self,\n        sobject: str,\n        id_: str,\n        /,\n        data: dict | str | bytes | bytearray,\n    ) -&gt; Subrequest:\n        \"\"\"\n        Update record by ID.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n            E.g. \"Account\", \"Contact\", etc.\n        id_ : str\n            Salesforce record ID.\n        data : dict | str | bytes | bytearray\n            Data to update the record with.\n            Either a dict or a JSON string/bytes representing a dict.\n\n        Returns\n        -------\n        Subrequest\n\n        \"\"\"\n        subrequest = Subrequest(\n            \"PATCH\",\n            f\"{self.base_path}/{sobject}/{id_}\",\n            rich_input=data if isinstance(data, dict) else json_loads(data),\n        )\n        self.composite_batch_request.subrequests.append(subrequest)\n        return subrequest\n\n    def delete(\n        self,\n        sobject: str,\n        id_: str,\n        /,\n        external_id_field: str | None = None,\n    ) -&gt; Subrequest:\n        \"\"\"\n        Delete record by ID.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n            E.g. \"Account\", \"Contact\", etc.\n        id_ : str\n            Salesforce record ID or external ID (if external_id_field is provided).\n        external_id_field : str, optional\n            External ID field name.\n            If not provided, id_ is treated as a record ID.\n\n        Returns\n        -------\n        Subrequest\n\n        \"\"\"\n        url = f\"{self.base_path}/{sobject}\"\n        if external_id_field is None:\n            url += f\"/{id_}\"\n        else:\n            url += f\"/{external_id_field}/{id_}\"\n        subrequest = Subrequest(\"DELETE\", url)\n        self.composite_batch_request.subrequests.append(subrequest)\n        return subrequest\n\n    def upsert(\n        self,\n        sobject: str,\n        id_: str,\n        /,\n        external_id_field: str,\n        data: dict | str | bytes | bytearray,\n        validate: bool = True,\n    ) -&gt; SobjectUpsertSubrequest:\n        \"\"\"\n        Upsert (update if exists, create if not) record by external ID.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n            E.g. \"Account\", \"Contact\", etc.\n        id_ : str\n            Salesforce record external ID.\n        external_id_field : str\n            External ID field name.\n        data : dict | str | bytes | bytearray\n            Data to upsert the record with.\n            Either a dict or a JSON string/bytes representing a dict.\n        validate : bool, default True\n            If True, validates the request and removes the external ID field\n            from the data if it's present. By default True.\n            The reason for this is that Salesforce does not allow\n            payload to contain an external ID field when upserting on it.\n            Set this to False if you know you data is correct and\n            you want to improve performance.\n\n        Returns\n        -------\n        SobjectUpsertSubrequest\n            Upsert subrequest.\n            Exposes 'id' and 'created' properties.\n\n        \"\"\"\n        if validate:\n            if isinstance(data, (str, bytes, bytearray)):\n                data = json_loads(data)\n            else:\n                # Copy payload to avoid mutating the original\n                data = json_loads(json_dumps(data))\n            if not isinstance(data, dict):\n                raise TypeError(\n                    f\"data must be a dict, str, bytes, or bytearray, \"\n                    f\"got {type(data).__name__}\"\n                )\n            try:\n                if str(data[external_id_field]) != str(id_):\n                    raise ValueError(\n                        f\"External ID field '{external_id_field}' in data \"\n                        f\"{data[external_id_field]} does not match \"\n                        f\"the provided external id '{id_}'\"\n                    )\n                data.pop(external_id_field)\n            except KeyError:\n                pass\n\n        subrequest = SobjectUpsertSubrequest(\n            \"PATCH\",\n            f\"{self.base_path}/{sobject}/{external_id_field}/{id_}\",\n            rich_input=data if isinstance(data, dict) else json_loads(data),\n        )\n        self.composite_batch_request.subrequests.append(subrequest)\n        return subrequest\n</code></pre>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.SobjectSubrequestClient.base_path","title":"<code>base_path: str = '/'.join(['', 'services', 'data', f'v{self.composite_batch_request.salesforce_client.version}', 'sobjects'])</code>  <code>instance-attribute</code>","text":"<p>Base path in the format /services/data/v[version]/sobjects</p>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.SobjectSubrequestClient.create","title":"<code>create(sobject, /, data)</code>","text":"<p>Create a new record.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name. E.g. \"Account\", \"Contact\", etc.</p> required <code>data</code> <code>dict | str | bytes | bytearray</code> <p>Data to create the record with. Either a dict or a JSON string/bytes representing a dict.</p> required <p>Returns:</p> Type Description <code>SobjectCreateSubrequest</code> <p>Create subrequest. Record ID can be accessed via the <code>id</code> property.</p> Source code in <code>src/aiosalesforce/composite/batch.py</code> <pre><code>def create(\n    self,\n    sobject: str,\n    /,\n    data: dict | str | bytes | bytearray,\n) -&gt; SobjectCreateSubrequest:\n    \"\"\"\n    Create a new record.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n        E.g. \"Account\", \"Contact\", etc.\n    data : dict | str | bytes | bytearray\n        Data to create the record with.\n        Either a dict or a JSON string/bytes representing a dict.\n\n    Returns\n    -------\n    SobjectCreateSubrequest\n        Create subrequest.\n        Record ID can be accessed via the `id` property.\n\n    \"\"\"\n    subrequest = SobjectCreateSubrequest(\n        \"POST\",\n        f\"{self.base_path}/{sobject}\",\n        rich_input=data if isinstance(data, dict) else json_loads(data),\n    )\n    self.composite_batch_request.subrequests.append(subrequest)\n    return subrequest\n</code></pre>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.SobjectSubrequestClient.get","title":"<code>get(sobject, id_, /, external_id_field=None, fields=None)</code>","text":"<p>Get record by ID or external ID.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name. E.g. \"Account\", \"Contact\", etc.</p> required <code>id_</code> <code>str</code> <p>Salesforce record ID or external ID (if external_id_field is provided).</p> required <code>external_id_field</code> <code>str</code> <p>External ID field name, by default None.</p> <code>None</code> <code>fields</code> <code>Iterable[str]</code> <p>Fields to get for the record. By default returns all fields.</p> <code>None</code> <p>Returns:</p> Type Description <code>SobbjectGetSubrequest</code> <p>Get subrequest. Record can be accessed via the <code>record</code> property.</p> Source code in <code>src/aiosalesforce/composite/batch.py</code> <pre><code>def get(\n    self,\n    sobject: str,\n    id_: str,\n    /,\n    external_id_field: str | None = None,\n    fields: Iterable[str] | None = None,\n) -&gt; SobjectGetSubrequest:\n    \"\"\"\n    Get record by ID or external ID.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n        E.g. \"Account\", \"Contact\", etc.\n    id_ : str\n        Salesforce record ID or external ID (if external_id_field is provided).\n    external_id_field : str, optional\n        External ID field name, by default None.\n    fields : Iterable[str], optional\n        Fields to get for the record.\n        By default returns all fields.\n\n    Returns\n    -------\n    SobbjectGetSubrequest\n        Get subrequest.\n        Record can be accessed via the `record` property.\n\n    \"\"\"\n    url = httpx.URL(\n        \"/\".join(\n            [\n                self.base_path,\n                sobject,\n                id_ if external_id_field is None else f\"{external_id_field}/{id_}\",\n            ]\n        )\n    )\n    if fields is not None:\n        url = url.copy_add_param(\"fields\", \",\".join(fields))\n    subrequest = SobjectGetSubrequest(\"GET\", str(url))\n    self.composite_batch_request.subrequests.append(subrequest)\n    return subrequest\n</code></pre>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.SobjectSubrequestClient.update","title":"<code>update(sobject, id_, /, data)</code>","text":"<p>Update record by ID.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name. E.g. \"Account\", \"Contact\", etc.</p> required <code>id_</code> <code>str</code> <p>Salesforce record ID.</p> required <code>data</code> <code>dict | str | bytes | bytearray</code> <p>Data to update the record with. Either a dict or a JSON string/bytes representing a dict.</p> required <p>Returns:</p> Type Description <code>Subrequest</code> Source code in <code>src/aiosalesforce/composite/batch.py</code> <pre><code>def update(\n    self,\n    sobject: str,\n    id_: str,\n    /,\n    data: dict | str | bytes | bytearray,\n) -&gt; Subrequest:\n    \"\"\"\n    Update record by ID.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n        E.g. \"Account\", \"Contact\", etc.\n    id_ : str\n        Salesforce record ID.\n    data : dict | str | bytes | bytearray\n        Data to update the record with.\n        Either a dict or a JSON string/bytes representing a dict.\n\n    Returns\n    -------\n    Subrequest\n\n    \"\"\"\n    subrequest = Subrequest(\n        \"PATCH\",\n        f\"{self.base_path}/{sobject}/{id_}\",\n        rich_input=data if isinstance(data, dict) else json_loads(data),\n    )\n    self.composite_batch_request.subrequests.append(subrequest)\n    return subrequest\n</code></pre>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.SobjectSubrequestClient.delete","title":"<code>delete(sobject, id_, /, external_id_field=None)</code>","text":"<p>Delete record by ID.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name. E.g. \"Account\", \"Contact\", etc.</p> required <code>id_</code> <code>str</code> <p>Salesforce record ID or external ID (if external_id_field is provided).</p> required <code>external_id_field</code> <code>str</code> <p>External ID field name. If not provided, id_ is treated as a record ID.</p> <code>None</code> <p>Returns:</p> Type Description <code>Subrequest</code> Source code in <code>src/aiosalesforce/composite/batch.py</code> <pre><code>def delete(\n    self,\n    sobject: str,\n    id_: str,\n    /,\n    external_id_field: str | None = None,\n) -&gt; Subrequest:\n    \"\"\"\n    Delete record by ID.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n        E.g. \"Account\", \"Contact\", etc.\n    id_ : str\n        Salesforce record ID or external ID (if external_id_field is provided).\n    external_id_field : str, optional\n        External ID field name.\n        If not provided, id_ is treated as a record ID.\n\n    Returns\n    -------\n    Subrequest\n\n    \"\"\"\n    url = f\"{self.base_path}/{sobject}\"\n    if external_id_field is None:\n        url += f\"/{id_}\"\n    else:\n        url += f\"/{external_id_field}/{id_}\"\n    subrequest = Subrequest(\"DELETE\", url)\n    self.composite_batch_request.subrequests.append(subrequest)\n    return subrequest\n</code></pre>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.SobjectSubrequestClient.upsert","title":"<code>upsert(sobject, id_, /, external_id_field, data, validate=True)</code>","text":"<p>Upsert (update if exists, create if not) record by external ID.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name. E.g. \"Account\", \"Contact\", etc.</p> required <code>id_</code> <code>str</code> <p>Salesforce record external ID.</p> required <code>external_id_field</code> <code>str</code> <p>External ID field name.</p> required <code>data</code> <code>dict | str | bytes | bytearray</code> <p>Data to upsert the record with. Either a dict or a JSON string/bytes representing a dict.</p> required <code>validate</code> <code>bool</code> <p>If True, validates the request and removes the external ID field from the data if it's present. By default True. The reason for this is that Salesforce does not allow payload to contain an external ID field when upserting on it. Set this to False if you know you data is correct and you want to improve performance.</p> <code>True</code> <p>Returns:</p> Type Description <code>SobjectUpsertSubrequest</code> <p>Upsert subrequest. Exposes 'id' and 'created' properties.</p> Source code in <code>src/aiosalesforce/composite/batch.py</code> <pre><code>def upsert(\n    self,\n    sobject: str,\n    id_: str,\n    /,\n    external_id_field: str,\n    data: dict | str | bytes | bytearray,\n    validate: bool = True,\n) -&gt; SobjectUpsertSubrequest:\n    \"\"\"\n    Upsert (update if exists, create if not) record by external ID.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n        E.g. \"Account\", \"Contact\", etc.\n    id_ : str\n        Salesforce record external ID.\n    external_id_field : str\n        External ID field name.\n    data : dict | str | bytes | bytearray\n        Data to upsert the record with.\n        Either a dict or a JSON string/bytes representing a dict.\n    validate : bool, default True\n        If True, validates the request and removes the external ID field\n        from the data if it's present. By default True.\n        The reason for this is that Salesforce does not allow\n        payload to contain an external ID field when upserting on it.\n        Set this to False if you know you data is correct and\n        you want to improve performance.\n\n    Returns\n    -------\n    SobjectUpsertSubrequest\n        Upsert subrequest.\n        Exposes 'id' and 'created' properties.\n\n    \"\"\"\n    if validate:\n        if isinstance(data, (str, bytes, bytearray)):\n            data = json_loads(data)\n        else:\n            # Copy payload to avoid mutating the original\n            data = json_loads(json_dumps(data))\n        if not isinstance(data, dict):\n            raise TypeError(\n                f\"data must be a dict, str, bytes, or bytearray, \"\n                f\"got {type(data).__name__}\"\n            )\n        try:\n            if str(data[external_id_field]) != str(id_):\n                raise ValueError(\n                    f\"External ID field '{external_id_field}' in data \"\n                    f\"{data[external_id_field]} does not match \"\n                    f\"the provided external id '{id_}'\"\n                )\n            data.pop(external_id_field)\n        except KeyError:\n            pass\n\n    subrequest = SobjectUpsertSubrequest(\n        \"PATCH\",\n        f\"{self.base_path}/{sobject}/{external_id_field}/{id_}\",\n        rich_input=data if isinstance(data, dict) else json_loads(data),\n    )\n    self.composite_batch_request.subrequests.append(subrequest)\n    return subrequest\n</code></pre>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.CompositeBatchRequest","title":"<code>CompositeBatchRequest</code>","text":"<p>Composite Batch request.</p> <p>Parameters:</p> Name Type Description Default <code>salesforce_client</code> <code>Salesforce</code> <p>Salesforce client.</p> required <code>halt_on_error</code> <code>bool</code> <p>If True, unprocessed subrequests will be halted if any subrequest fails.</p> <code>False</code> <code>autoraise</code> <code>bool</code> <p>If True, an exception will be raised if any subrequest fails.</p> <code>False</code> <code>group_errors</code> <code>bool</code> <p>Ignored if <code>autoraise</code> is False. If True, raises an ExceptionGroup with all errors. Otherwise, raises the first exception.</p> <code>False</code> Source code in <code>src/aiosalesforce/composite/batch.py</code> <pre><code>class CompositeBatchRequest:\n    \"\"\"\n    Composite Batch request.\n\n    Parameters\n    ----------\n    salesforce_client : Salesforce\n        Salesforce client.\n    halt_on_error : bool, default False\n        If True, unprocessed subrequests will be halted if any subrequest fails.\n    autoraise : bool, default False\n        If True, an exception will be raised if any subrequest fails.\n    group_errors : bool, default False\n        Ignored if `autoraise` is False.\n        If True, raises an ExceptionGroup with all errors.\n        Otherwise, raises the first exception.\n\n    \"\"\"\n\n    salesforce_client: \"Salesforce\"\n    halt_on_error: bool\n    autoraise: bool\n    group_errors: bool\n\n    subrequests: list[Subrequest]\n\n    def __init__(\n        self,\n        salesforce_client: \"Salesforce\",\n        halt_on_error: bool = False,\n        autoraise: bool = False,\n        group_errors: bool = False,\n    ) -&gt; None:\n        self.salesforce_client = salesforce_client\n        self.halt_on_error = halt_on_error\n        self.autoraise = autoraise\n        self.group_errors = group_errors\n\n        self.subrequests = []\n\n    async def execute(self) -&gt; None:\n        \"\"\"Execute composite batch request and set subrequests' responses.\"\"\"\n        if len(self.subrequests) == 0:\n            return\n        response = await self.salesforce_client.request(\n            \"POST\",\n            \"/\".join(\n                [\n                    self.salesforce_client.base_url,\n                    \"services\",\n                    \"data\",\n                    f\"v{self.salesforce_client.version}\",\n                    \"composite\",\n                    \"batch\",\n                ]\n            ),\n            content=json_dumps(\n                {\n                    \"haltOnError\": self.halt_on_error,\n                    \"batchRequests\": [\n                        subrequest.to_dict() for subrequest in self.subrequests\n                    ],\n                }\n            ),\n            headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n        )\n        for subrequest, subrequest_response in zip(\n            self.subrequests,\n            # Salesforce escapes characters in Composite JSON response as if it was HTML\n            json_loads(unescape(response.content.decode(\"utf-8\")))[\"results\"],\n        ):\n            subrequest.response = subrequest_response\n        if self.autoraise:\n            errors: list[Exception] = []\n            for subrequest in self.subrequests:\n                try:\n                    subrequest.raise_for_status()\n                except Exception as exc:\n                    errors.append(exc)\n            if len(errors) &gt; 0:\n                if self.group_errors:\n                    raise ExceptionGroup(\"Composite Batch request error\", errors)\n                raise errors[0]\n\n    async def __aenter__(self) -&gt; \"CompositeBatchRequest\":\n        return self\n\n    async def __aexit__(self, exc_type, exc, tb) -&gt; None:\n        # Execute only if no exception occurred\n        if exc is None:\n            await self.execute()\n\n    def query(self, query: str, include_all_records: bool = False) -&gt; QuerySubrequest:\n        \"\"\"\n        Execute a SOQL query.\n\n        Parameters\n        ----------\n        query : str\n            SOQL query.\n        include_all_records : bool, default False\n            If True, includes all (active/deleted/archived) records.\n\n        Returns\n        -------\n        QuerySubrequest\n            Query subrequest.\n            Records can be accessed via the `records` property.\n\n        \"\"\"\n        url = httpx.URL(\n            \"/\".join(\n                [\n                    \"\",\n                    \"services\",\n                    \"data\",\n                    f\"v{self.salesforce_client.version}\",\n                    \"query\" if not include_all_records else \"queryAll\",\n                ]\n            )\n        ).copy_add_param(\"q\", query)\n        subrequest = QuerySubrequest(\"GET\", str(url))\n        self.subrequests.append(subrequest)\n        return subrequest\n\n    @cached_property\n    def sobject(self) -&gt; SobjectSubrequestClient:\n        \"\"\"Perform sObject operations.\"\"\"\n        return SobjectSubrequestClient(self)\n</code></pre>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.CompositeBatchRequest.sobject","title":"<code>sobject: SobjectSubrequestClient</code>  <code>cached</code> <code>property</code>","text":"<p>Perform sObject operations.</p>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.CompositeBatchRequest.execute","title":"<code>execute()</code>  <code>async</code>","text":"<p>Execute composite batch request and set subrequests' responses.</p> Source code in <code>src/aiosalesforce/composite/batch.py</code> <pre><code>async def execute(self) -&gt; None:\n    \"\"\"Execute composite batch request and set subrequests' responses.\"\"\"\n    if len(self.subrequests) == 0:\n        return\n    response = await self.salesforce_client.request(\n        \"POST\",\n        \"/\".join(\n            [\n                self.salesforce_client.base_url,\n                \"services\",\n                \"data\",\n                f\"v{self.salesforce_client.version}\",\n                \"composite\",\n                \"batch\",\n            ]\n        ),\n        content=json_dumps(\n            {\n                \"haltOnError\": self.halt_on_error,\n                \"batchRequests\": [\n                    subrequest.to_dict() for subrequest in self.subrequests\n                ],\n            }\n        ),\n        headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n    )\n    for subrequest, subrequest_response in zip(\n        self.subrequests,\n        # Salesforce escapes characters in Composite JSON response as if it was HTML\n        json_loads(unescape(response.content.decode(\"utf-8\")))[\"results\"],\n    ):\n        subrequest.response = subrequest_response\n    if self.autoraise:\n        errors: list[Exception] = []\n        for subrequest in self.subrequests:\n            try:\n                subrequest.raise_for_status()\n            except Exception as exc:\n                errors.append(exc)\n        if len(errors) &gt; 0:\n            if self.group_errors:\n                raise ExceptionGroup(\"Composite Batch request error\", errors)\n            raise errors[0]\n</code></pre>"},{"location":"api-reference/composite/batch/#aiosalesforce.composite.batch.CompositeBatchRequest.query","title":"<code>query(query, include_all_records=False)</code>","text":"<p>Execute a SOQL query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>SOQL query.</p> required <code>include_all_records</code> <code>bool</code> <p>If True, includes all (active/deleted/archived) records.</p> <code>False</code> <p>Returns:</p> Type Description <code>QuerySubrequest</code> <p>Query subrequest. Records can be accessed via the <code>records</code> property.</p> Source code in <code>src/aiosalesforce/composite/batch.py</code> <pre><code>def query(self, query: str, include_all_records: bool = False) -&gt; QuerySubrequest:\n    \"\"\"\n    Execute a SOQL query.\n\n    Parameters\n    ----------\n    query : str\n        SOQL query.\n    include_all_records : bool, default False\n        If True, includes all (active/deleted/archived) records.\n\n    Returns\n    -------\n    QuerySubrequest\n        Query subrequest.\n        Records can be accessed via the `records` property.\n\n    \"\"\"\n    url = httpx.URL(\n        \"/\".join(\n            [\n                \"\",\n                \"services\",\n                \"data\",\n                f\"v{self.salesforce_client.version}\",\n                \"query\" if not include_all_records else \"queryAll\",\n            ]\n        )\n    ).copy_add_param(\"q\", query)\n    subrequest = QuerySubrequest(\"GET\", str(url))\n    self.subrequests.append(subrequest)\n    return subrequest\n</code></pre>"},{"location":"api-reference/composite/client/","title":"Client","text":""},{"location":"api-reference/composite/client/#aiosalesforce.composite.client.CompositeClient","title":"<code>CompositeClient</code>","text":"<p>Salesforce REST API Composite client.</p> <p>Parameters:</p> Name Type Description Default <code>salesforce_client</code> <code>Salesforce</code> <p>Salesforce client.</p> required Source code in <code>src/aiosalesforce/composite/client.py</code> <pre><code>class CompositeClient:\n    \"\"\"\n    Salesforce REST API Composite client.\n\n    Parameters\n    ----------\n    salesforce_client : Salesforce\n        Salesforce client.\n\n    \"\"\"\n\n    salesforce_client: \"Salesforce\"\n\n    def __init__(self, salesforce_client: \"Salesforce\") -&gt; None:\n        self.salesforce_client = salesforce_client\n\n    def batch(\n        self,\n        halt_on_error: bool = False,\n        autoraise: bool = False,\n        group_errors: bool = False,\n    ) -&gt; CompositeBatchRequest:\n        \"\"\"\n        Start a Comsposite Batch operation.\n\n        To execute a batch request, add subrequests to the batch and call `execute`.\n        Alternatively, use a context manager to automatically execute the batch.\n\n        Parameters\n        ----------\n        halt_on_error : bool, default False\n            If True, unprocessed subrequests will be halted if any subrequest fails.\n        autoraise : bool, default False\n            If True, an exception will be raised if any subrequest fails.\n        group_errors : bool, default False\n            Ignored if `autoraise` is False.\n            If True, raises an ExceptionGroup with all errors.\n            Otherwise, raises the first exception.\n\n        Returns\n        -------\n        CompositeBatchRequest\n            Composite Batch request.\n\n        Examples\n        --------\n        &gt;&gt;&gt; async with salesforce.composite.batch(halt_on_error=True) as batch:\n        ...     query = batch.query(\"SELECT Id, Name FROM Account LIMIT 10\")\n        ...     contact = batch.sobject.create(\n        ...         \"Contact\",\n        ...         {\"FirstName\": \"Jon\", \"LastName\": \"Doe\"},\n        ...     )\n        ... print(query.records)\n        ... print(contact.id)\n\n        \"\"\"\n        return CompositeBatchRequest(\n            salesforce_client=self.salesforce_client,\n            halt_on_error=halt_on_error,\n            autoraise=autoraise,\n            group_errors=group_errors,\n        )\n\n    def __call__(\n        self,\n        all_or_none: bool = False,\n        collate_subrequests: bool = False,\n        autoraise: bool = False,\n    ) -&gt; CompositeRequest:\n        \"\"\"\n        Start a Comsposite operation.\n\n        To execute a composite request, add subrequests to it and call `execute`.\n        Alternatively, use a context manager to automatically execute the request.\n\n        Parameters\n        ----------\n        all_or_none : bool, default False\n            If True, all subrequests are rolled back if any subrequest fails.\n        collate_subrequests : bool, default True\n            If True, independent subrequests are executed by Salesforce in parallel.\n        autoraise : bool, default False\n            If True, raises an ExceptionGroup if any subrequest fails.\n\n        Returns\n        -------\n        CompositeRequest\n            Composite request.\n\n        Examples\n        --------\n        &gt;&gt;&gt; async with salesforce.composite(all_or_none=True) as batch:\n        ...     account = composite.sobject.create(\n        ...         \"Account\",\n        ...         {...},\n        ...     )\n        ...     contact = composite.sobject.create(\n        ...         \"Contact\",\n        ...         {\"Account\": account.reference.id, ...}\n        ...     )\n        ... print(account.id)\n        ... print(contact.id)\n\n        \"\"\"\n        return CompositeRequest(\n            salesforce_client=self.salesforce_client,\n            all_or_none=all_or_none,\n            collate_subrequests=collate_subrequests,\n            autoraise=autoraise,\n        )\n</code></pre>"},{"location":"api-reference/composite/client/#aiosalesforce.composite.client.CompositeClient.batch","title":"<code>batch(halt_on_error=False, autoraise=False, group_errors=False)</code>","text":"<p>Start a Comsposite Batch operation.</p> <p>To execute a batch request, add subrequests to the batch and call <code>execute</code>. Alternatively, use a context manager to automatically execute the batch.</p> <p>Parameters:</p> Name Type Description Default <code>halt_on_error</code> <code>bool</code> <p>If True, unprocessed subrequests will be halted if any subrequest fails.</p> <code>False</code> <code>autoraise</code> <code>bool</code> <p>If True, an exception will be raised if any subrequest fails.</p> <code>False</code> <code>group_errors</code> <code>bool</code> <p>Ignored if <code>autoraise</code> is False. If True, raises an ExceptionGroup with all errors. Otherwise, raises the first exception.</p> <code>False</code> <p>Returns:</p> Type Description <code>CompositeBatchRequest</code> <p>Composite Batch request.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async with salesforce.composite.batch(halt_on_error=True) as batch:\n...     query = batch.query(\"SELECT Id, Name FROM Account LIMIT 10\")\n...     contact = batch.sobject.create(\n...         \"Contact\",\n...         {\"FirstName\": \"Jon\", \"LastName\": \"Doe\"},\n...     )\n... print(query.records)\n... print(contact.id)\n</code></pre> Source code in <code>src/aiosalesforce/composite/client.py</code> <pre><code>def batch(\n    self,\n    halt_on_error: bool = False,\n    autoraise: bool = False,\n    group_errors: bool = False,\n) -&gt; CompositeBatchRequest:\n    \"\"\"\n    Start a Comsposite Batch operation.\n\n    To execute a batch request, add subrequests to the batch and call `execute`.\n    Alternatively, use a context manager to automatically execute the batch.\n\n    Parameters\n    ----------\n    halt_on_error : bool, default False\n        If True, unprocessed subrequests will be halted if any subrequest fails.\n    autoraise : bool, default False\n        If True, an exception will be raised if any subrequest fails.\n    group_errors : bool, default False\n        Ignored if `autoraise` is False.\n        If True, raises an ExceptionGroup with all errors.\n        Otherwise, raises the first exception.\n\n    Returns\n    -------\n    CompositeBatchRequest\n        Composite Batch request.\n\n    Examples\n    --------\n    &gt;&gt;&gt; async with salesforce.composite.batch(halt_on_error=True) as batch:\n    ...     query = batch.query(\"SELECT Id, Name FROM Account LIMIT 10\")\n    ...     contact = batch.sobject.create(\n    ...         \"Contact\",\n    ...         {\"FirstName\": \"Jon\", \"LastName\": \"Doe\"},\n    ...     )\n    ... print(query.records)\n    ... print(contact.id)\n\n    \"\"\"\n    return CompositeBatchRequest(\n        salesforce_client=self.salesforce_client,\n        halt_on_error=halt_on_error,\n        autoraise=autoraise,\n        group_errors=group_errors,\n    )\n</code></pre>"},{"location":"api-reference/composite/client/#aiosalesforce.composite.client.CompositeClient.__call__","title":"<code>__call__(all_or_none=False, collate_subrequests=False, autoraise=False)</code>","text":"<p>Start a Comsposite operation.</p> <p>To execute a composite request, add subrequests to it and call <code>execute</code>. Alternatively, use a context manager to automatically execute the request.</p> <p>Parameters:</p> Name Type Description Default <code>all_or_none</code> <code>bool</code> <p>If True, all subrequests are rolled back if any subrequest fails.</p> <code>False</code> <code>collate_subrequests</code> <code>bool</code> <p>If True, independent subrequests are executed by Salesforce in parallel.</p> <code>True</code> <code>autoraise</code> <code>bool</code> <p>If True, raises an ExceptionGroup if any subrequest fails.</p> <code>False</code> <p>Returns:</p> Type Description <code>CompositeRequest</code> <p>Composite request.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async with salesforce.composite(all_or_none=True) as batch:\n...     account = composite.sobject.create(\n...         \"Account\",\n...         {...},\n...     )\n...     contact = composite.sobject.create(\n...         \"Contact\",\n...         {\"Account\": account.reference.id, ...}\n...     )\n... print(account.id)\n... print(contact.id)\n</code></pre> Source code in <code>src/aiosalesforce/composite/client.py</code> <pre><code>def __call__(\n    self,\n    all_or_none: bool = False,\n    collate_subrequests: bool = False,\n    autoraise: bool = False,\n) -&gt; CompositeRequest:\n    \"\"\"\n    Start a Comsposite operation.\n\n    To execute a composite request, add subrequests to it and call `execute`.\n    Alternatively, use a context manager to automatically execute the request.\n\n    Parameters\n    ----------\n    all_or_none : bool, default False\n        If True, all subrequests are rolled back if any subrequest fails.\n    collate_subrequests : bool, default True\n        If True, independent subrequests are executed by Salesforce in parallel.\n    autoraise : bool, default False\n        If True, raises an ExceptionGroup if any subrequest fails.\n\n    Returns\n    -------\n    CompositeRequest\n        Composite request.\n\n    Examples\n    --------\n    &gt;&gt;&gt; async with salesforce.composite(all_or_none=True) as batch:\n    ...     account = composite.sobject.create(\n    ...         \"Account\",\n    ...         {...},\n    ...     )\n    ...     contact = composite.sobject.create(\n    ...         \"Contact\",\n    ...         {\"Account\": account.reference.id, ...}\n    ...     )\n    ... print(account.id)\n    ... print(contact.id)\n\n    \"\"\"\n    return CompositeRequest(\n        salesforce_client=self.salesforce_client,\n        all_or_none=all_or_none,\n        collate_subrequests=collate_subrequests,\n        autoraise=autoraise,\n    )\n</code></pre>"},{"location":"api-reference/composite/composite/","title":"Composite","text":""},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.Reference","title":"<code>Reference</code>","text":"<p>             Bases: <code>str</code></p> <p>Abstract reference to a subrequest result.</p> <p>Used to recursively traverse the reference chain using attribute access ($.attr) and item access ($[index]). For example, <code>ref.children[0].Id</code>.</p> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>class Reference(str):\n    \"\"\"\n    Abstract reference to a subrequest result.\n\n    Used to recursively traverse the reference chain using attribute access ($.attr)\n    and item access ($[index]). For example, `ref.children[0].Id`.\n\n    \"\"\"\n\n    def __init__(self, ref: str) -&gt; None:\n        self.ref = ref\n\n    def __getattr__(self, attr: str) -&gt; \"Reference\":\n        return Reference(f\"{self.ref}.{attr}\")\n\n    def __getitem__(self, index) -&gt; \"Reference\":\n        return Reference(f\"{self.ref}[{index}]\")\n\n    def __repr__(self) -&gt; str:\n        return f\"@{{{self.ref}}}\"\n\n    def __str__(self) -&gt; str:\n        return repr(self)\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.Subrequest","title":"<code>Subrequest</code>","text":"<p>Composite subrequest.</p> <p>Parameters:</p> Name Type Description Default <code>reference_id</code> <code>str</code> <p>Reference ID.</p> required <code>method</code> <code>Literal['GET', 'POST', 'PUT', 'PATCH', 'DELETE']</code> <p>HTTP method.</p> required <code>url</code> <code>str</code> <p>Request URL.</p> required <code>body</code> <code>dict | None</code> <p>Request body.</p> <code>None</code> <code>http_headers</code> <code>dict | None</code> <p>Request headers.</p> <code>None</code> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>class Subrequest:\n    \"\"\"\n    Composite subrequest.\n\n    Parameters\n    ----------\n    reference_id : str\n        Reference ID.\n    method : Literal[\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"]\n        HTTP method.\n    url : str\n        Request URL.\n    body: dict, optional\n        Request body.\n    http_headers: dict, optional\n        Request headers.\n\n    \"\"\"\n\n    reference_id: str\n    method: Literal[\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"]\n    url: str\n    body: dict | None\n    http_headers: dict | None\n\n    __response: dict | None = None\n\n    def __init__(\n        self,\n        reference_id: str,\n        method: Literal[\"GET\", \"POST\", \"PUT\", \"PATCH\", \"DELETE\"],\n        url: str,\n        body: dict | None = None,\n        http_headers: dict | None = None,\n    ) -&gt; None:\n        self.reference_id = reference_id\n        self.method = method\n        self.url = url\n        self.body = body\n        self.http_headers = http_headers\n\n        self.__response = None\n\n    def to_dict(self) -&gt; dict:\n        payload = {\n            \"referenceId\": self.reference_id,\n            \"method\": self.method,\n            \"url\": self.url,\n            \"body\": self.body,\n            \"httpHeaders\": self.http_headers,\n        }\n        return {key: value for key, value in payload.items() if value is not None}\n\n    @property\n    def reference(self) -&gt; Reference:\n        \"\"\"\n        Reference result of this subrequest in another subrequest.\n\n        Examples\n        --------\n        &gt;&gt;&gt; account = composite.sobject.create(\n        ...     \"Account\",\n        ...     {...},\n        ... )\n        ... contact = composite.sobject.create(\n        ...     \"Contact\",\n        ...     {\"Account\": account.reference.id, ...}\n        ... )\n\n        \"\"\"\n        return Reference(self.reference_id)\n\n    @property\n    def response(self) -&gt; dict:\n        \"\"\"Subrequest response.\"\"\"\n        if self.__response is None:\n            raise InvalidStateError(\"Subrequest response has not been set\")\n        return self.__response\n\n    @response.setter\n    def response(self, value: dict) -&gt; None:\n        self.__response = value\n\n    @property\n    def done(self) -&gt; bool:\n        \"\"\"Whether the subrequest has been executed.\"\"\"\n        return self.response is not None\n\n    @property\n    def response_body(self) -&gt; dict | list | None:\n        \"\"\"Subrequest response body.\"\"\"\n        return self.response[\"body\"]\n\n    @property\n    def response_http_headers(self) -&gt; dict:\n        \"\"\"Subrequest response HTTP headers.\"\"\"\n        return self.response[\"httpHeaders\"]\n\n    @property\n    def status_code(self) -&gt; int:\n        \"\"\"HTTP status code of the subrequest response.\"\"\"\n        return self.response[\"httpStatusCode\"]\n\n    @property\n    def is_success(self) -&gt; bool:\n        \"\"\"Whether this subrequest was successful.\"\"\"\n        return 200 &lt;= self.status_code &lt; 300\n\n    def raise_for_status(self) -&gt; None:\n        \"\"\"Raise an exception if this subrequest failed.\"\"\"\n        if not self.is_success:\n            raise_salesforce_error(\n                httpx.Response(\n                    self.status_code,\n                    headers=self.response_http_headers,\n                    json=self.response_body,\n                )\n            )\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.Subrequest.reference","title":"<code>reference: Reference</code>  <code>property</code>","text":"<p>Reference result of this subrequest in another subrequest.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; account = composite.sobject.create(\n...     \"Account\",\n...     {...},\n... )\n... contact = composite.sobject.create(\n...     \"Contact\",\n...     {\"Account\": account.reference.id, ...}\n... )\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.Subrequest.response","title":"<code>response: dict</code>  <code>property</code> <code>writable</code>","text":"<p>Subrequest response.</p>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.Subrequest.done","title":"<code>done: bool</code>  <code>property</code>","text":"<p>Whether the subrequest has been executed.</p>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.Subrequest.response_body","title":"<code>response_body: dict | list | None</code>  <code>property</code>","text":"<p>Subrequest response body.</p>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.Subrequest.response_http_headers","title":"<code>response_http_headers: dict</code>  <code>property</code>","text":"<p>Subrequest response HTTP headers.</p>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.Subrequest.status_code","title":"<code>status_code: int</code>  <code>property</code>","text":"<p>HTTP status code of the subrequest response.</p>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.Subrequest.is_success","title":"<code>is_success: bool</code>  <code>property</code>","text":"<p>Whether this subrequest was successful.</p>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.Subrequest.raise_for_status","title":"<code>raise_for_status()</code>","text":"<p>Raise an exception if this subrequest failed.</p> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>def raise_for_status(self) -&gt; None:\n    \"\"\"Raise an exception if this subrequest failed.\"\"\"\n    if not self.is_success:\n        raise_salesforce_error(\n            httpx.Response(\n                self.status_code,\n                headers=self.response_http_headers,\n                json=self.response_body,\n            )\n        )\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.QuerySubrequest","title":"<code>QuerySubrequest</code>","text":"<p>             Bases: <code>Subrequest</code></p> <p>SOQL query subrequest.</p> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>class QuerySubrequest(Subrequest):\n    \"\"\"SOQL query subrequest.\"\"\"\n\n    @property\n    def records(self) -&gt; list[dict]:\n        \"\"\"Query records.\"\"\"\n        self.raise_for_status()\n        assert isinstance(self.response_body, dict)\n        return self.response_body[\"records\"]\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.QuerySubrequest.records","title":"<code>records: list[dict]</code>  <code>property</code>","text":"<p>Query records.</p>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.SobjectCreateSubrequest","title":"<code>SobjectCreateSubrequest</code>","text":"<p>             Bases: <code>Subrequest</code></p> <p>sObject create subrequest.</p> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>class SobjectCreateSubrequest(Subrequest):\n    \"\"\"sObject create subrequest.\"\"\"\n\n    @property\n    def id(self) -&gt; str:\n        \"\"\"ID of the created record.\"\"\"\n        self.raise_for_status()\n        assert isinstance(self.response_body, dict)\n        return self.response_body[\"id\"]\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.SobjectCreateSubrequest.id","title":"<code>id: str</code>  <code>property</code>","text":"<p>ID of the created record.</p>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.SobjectGetSubrequest","title":"<code>SobjectGetSubrequest</code>","text":"<p>             Bases: <code>Subrequest</code></p> <p>sObject get subrequest.</p> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>class SobjectGetSubrequest(Subrequest):\n    \"\"\"sObject get subrequest.\"\"\"\n\n    @property\n    def record(self) -&gt; dict:\n        \"\"\"Retrieved record.\"\"\"\n        self.raise_for_status()\n        assert isinstance(self.response_body, dict)\n        return self.response_body\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.SobjectGetSubrequest.record","title":"<code>record: dict</code>  <code>property</code>","text":"<p>Retrieved record.</p>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.SobjectUpsertSubrequest","title":"<code>SobjectUpsertSubrequest</code>","text":"<p>             Bases: <code>Subrequest</code></p> <p>sObject upsert subrequest.</p> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>class SobjectUpsertSubrequest(Subrequest):\n    \"\"\"sObject upsert subrequest.\"\"\"\n\n    @property\n    def id(self) -&gt; str:\n        \"\"\"ID of the upserted record.\"\"\"\n        self.raise_for_status()\n        assert isinstance(self.response_body, dict)\n        return self.response_body[\"id\"]\n\n    @property\n    def created(self) -&gt; bool:\n        \"\"\"Whether the record was created.\"\"\"\n        self.raise_for_status()\n        assert isinstance(self.response_body, dict)\n        return self.response_body[\"created\"]\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.SobjectUpsertSubrequest.id","title":"<code>id: str</code>  <code>property</code>","text":"<p>ID of the upserted record.</p>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.SobjectUpsertSubrequest.created","title":"<code>created: bool</code>  <code>property</code>","text":"<p>Whether the record was created.</p>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.SobjectSubrequestClient","title":"<code>SobjectSubrequestClient</code>","text":"<p>Client for sObject operations.</p> <p>Parameters:</p> Name Type Description Default <code>composite_request</code> <code>CompositeRequest</code> <p>Composite request.</p> required Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>class SobjectSubrequestClient:\n    \"\"\"\n    Client for sObject operations.\n\n    Parameters\n    ----------\n    composite_request : CompositeRequest\n        Composite request.\n\n    \"\"\"\n\n    composite_request: \"CompositeRequest\"\n    base_path: str\n    \"\"\"Base path in the format /services/data/v[version]/sobjects\"\"\"\n\n    def __init__(self, composite_request: \"CompositeRequest\") -&gt; None:\n        self.composite_request = composite_request\n        self.base_path = \"/\".join(\n            [\n                \"\",\n                \"services\",\n                \"data\",\n                f\"v{self.composite_request.salesforce_client.version}\",\n                \"sobjects\",\n            ]\n        )\n\n    def create(\n        self,\n        sobject: str,\n        /,\n        data: dict | str | bytes | bytearray,\n    ) -&gt; SobjectCreateSubrequest:\n        \"\"\"\n        Create a new record.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n            E.g. \"Account\", \"Contact\", etc.\n        data : dict | str | bytes | bytearray\n            Data to create the record with.\n            Either a dict or a JSON string/bytes representing a dict.\n\n        Returns\n        -------\n        SobjectCreateSubrequest\n            Create subrequest.\n            Record ID can be accessed via the `id` property.\n\n        \"\"\"\n        subrequest = SobjectCreateSubrequest(\n            self.composite_request.get_reference_id(f\"{sobject}_create\"),\n            \"POST\",\n            f\"{self.base_path}/{sobject}\",\n            body=data if isinstance(data, dict) else json_loads(data),\n        )\n        self.composite_request.add_subrequest(subrequest)\n        return subrequest\n\n    def get(\n        self,\n        sobject: str,\n        id_: str,\n        /,\n        external_id_field: str | None = None,\n        fields: Iterable[str] | None = None,\n    ) -&gt; SobjectGetSubrequest:\n        \"\"\"\n        Get record by ID or external ID.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n            E.g. \"Account\", \"Contact\", etc.\n        id_ : str\n            Salesforce record ID or external ID (if external_id_field is provided).\n        external_id_field : str, optional\n            External ID field name, by default None.\n        fields : Iterable[str], optional\n            Fields to get for the record.\n            By default returns all fields.\n\n        Returns\n        -------\n        SobbjectGetSubrequest\n            Get subrequest.\n            Record can be accessed via the `record` property.\n\n        \"\"\"\n        url = httpx.URL(\n            \"/\".join(\n                [\n                    self.base_path,\n                    sobject,\n                    id_ if external_id_field is None else f\"{external_id_field}/{id_}\",\n                ]\n            )\n        )\n        if fields is not None:\n            url = url.copy_add_param(\"fields\", \",\".join(fields))\n        subrequest = SobjectGetSubrequest(\n            self.composite_request.get_reference_id(f\"{sobject}_get\"),\n            \"GET\",\n            str(url),\n        )\n        self.composite_request.add_subrequest(subrequest)\n        return subrequest\n\n    def update(\n        self,\n        sobject: str,\n        id_: str,\n        /,\n        data: dict | str | bytes | bytearray,\n    ) -&gt; Subrequest:\n        \"\"\"\n        Update record by ID.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n            E.g. \"Account\", \"Contact\", etc.\n        id_ : str\n            Salesforce record ID.\n        data : dict | str | bytes | bytearray\n            Data to update the record with.\n            Either a dict or a JSON string/bytes representing a dict.\n\n        Returns\n        -------\n        Subrequest\n\n        \"\"\"\n        subrequest = Subrequest(\n            self.composite_request.get_reference_id(f\"{sobject}_update\"),\n            \"PATCH\",\n            f\"{self.base_path}/{sobject}/{id_}\",\n            body=data if isinstance(data, dict) else json_loads(data),\n        )\n        self.composite_request.add_subrequest(subrequest)\n        return subrequest\n\n    def delete(\n        self,\n        sobject: str,\n        id_: str,\n        /,\n        external_id_field: str | None = None,\n    ) -&gt; Subrequest:\n        \"\"\"\n        Delete record by ID.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n            E.g. \"Account\", \"Contact\", etc.\n        id_ : str\n            Salesforce record ID or external ID (if external_id_field is provided).\n        external_id_field : str, optional\n            External ID field name.\n            If not provided, id_ is treated as a record ID.\n\n        Returns\n        -------\n        Subrequest\n\n        \"\"\"\n        url = f\"{self.base_path}/{sobject}\"\n        if external_id_field is None:\n            url += f\"/{id_}\"\n        else:\n            url += f\"/{external_id_field}/{id_}\"\n        subrequest = Subrequest(\n            self.composite_request.get_reference_id(f\"{sobject}_delete\"),\n            \"DELETE\",\n            url,\n        )\n        self.composite_request.add_subrequest(subrequest)\n        return subrequest\n\n    def upsert(\n        self,\n        sobject: str,\n        id_: str,\n        /,\n        external_id_field: str,\n        data: dict | str | bytes | bytearray,\n        validate: bool = True,\n    ) -&gt; SobjectUpsertSubrequest:\n        \"\"\"\n        Upsert (update if exists, create if not) record by external ID.\n\n        Parameters\n        ----------\n        sobject : str\n            Salesforce object name.\n            E.g. \"Account\", \"Contact\", etc.\n        id_ : str\n            Salesforce record external ID.\n        external_id_field : str\n            External ID field name.\n        data : dict | str | bytes | bytearray\n            Data to upsert the record with.\n            Either a dict or a JSON string/bytes representing a dict.\n        validate : bool, default True\n            If True, validates the request and removes the external ID field\n            from the data if it's present. By default True.\n            The reason for this is that Salesforce does not allow\n            payload to contain an external ID field when upserting on it.\n            Set this to False if you know you data is correct and\n            you want to improve performance.\n\n        Returns\n        -------\n        SobjectUpsertSubrequest\n            Upsert subrequest.\n            Exposes 'id' and 'created' properties.\n\n        \"\"\"\n        if validate:\n            if isinstance(data, (str, bytes, bytearray)):\n                data = json_loads(data)\n            else:\n                # Copy payload to avoid mutating the original\n                data = json_loads(json_dumps(data))\n            if not isinstance(data, dict):\n                raise TypeError(\n                    f\"data must be a dict, str, bytes, or bytearray, \"\n                    f\"got {type(data).__name__}\"\n                )\n            try:\n                if str(data[external_id_field]) != str(id_):\n                    raise ValueError(\n                        f\"External ID field '{external_id_field}' in data \"\n                        f\"{data[external_id_field]} does not match \"\n                        f\"the provided external id '{id_}'\"\n                    )\n                data.pop(external_id_field)\n            except KeyError:\n                pass\n\n        subrequest = SobjectUpsertSubrequest(\n            self.composite_request.get_reference_id(f\"{sobject}_upsert\"),\n            \"PATCH\",\n            f\"{self.base_path}/{sobject}/{external_id_field}/{id_}\",\n            body=data if isinstance(data, dict) else json_loads(data),\n        )\n        self.composite_request.add_subrequest(subrequest)\n        return subrequest\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.SobjectSubrequestClient.base_path","title":"<code>base_path: str = '/'.join(['', 'services', 'data', f'v{self.composite_request.salesforce_client.version}', 'sobjects'])</code>  <code>instance-attribute</code>","text":"<p>Base path in the format /services/data/v[version]/sobjects</p>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.SobjectSubrequestClient.create","title":"<code>create(sobject, /, data)</code>","text":"<p>Create a new record.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name. E.g. \"Account\", \"Contact\", etc.</p> required <code>data</code> <code>dict | str | bytes | bytearray</code> <p>Data to create the record with. Either a dict or a JSON string/bytes representing a dict.</p> required <p>Returns:</p> Type Description <code>SobjectCreateSubrequest</code> <p>Create subrequest. Record ID can be accessed via the <code>id</code> property.</p> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>def create(\n    self,\n    sobject: str,\n    /,\n    data: dict | str | bytes | bytearray,\n) -&gt; SobjectCreateSubrequest:\n    \"\"\"\n    Create a new record.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n        E.g. \"Account\", \"Contact\", etc.\n    data : dict | str | bytes | bytearray\n        Data to create the record with.\n        Either a dict or a JSON string/bytes representing a dict.\n\n    Returns\n    -------\n    SobjectCreateSubrequest\n        Create subrequest.\n        Record ID can be accessed via the `id` property.\n\n    \"\"\"\n    subrequest = SobjectCreateSubrequest(\n        self.composite_request.get_reference_id(f\"{sobject}_create\"),\n        \"POST\",\n        f\"{self.base_path}/{sobject}\",\n        body=data if isinstance(data, dict) else json_loads(data),\n    )\n    self.composite_request.add_subrequest(subrequest)\n    return subrequest\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.SobjectSubrequestClient.get","title":"<code>get(sobject, id_, /, external_id_field=None, fields=None)</code>","text":"<p>Get record by ID or external ID.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name. E.g. \"Account\", \"Contact\", etc.</p> required <code>id_</code> <code>str</code> <p>Salesforce record ID or external ID (if external_id_field is provided).</p> required <code>external_id_field</code> <code>str</code> <p>External ID field name, by default None.</p> <code>None</code> <code>fields</code> <code>Iterable[str]</code> <p>Fields to get for the record. By default returns all fields.</p> <code>None</code> <p>Returns:</p> Type Description <code>SobbjectGetSubrequest</code> <p>Get subrequest. Record can be accessed via the <code>record</code> property.</p> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>def get(\n    self,\n    sobject: str,\n    id_: str,\n    /,\n    external_id_field: str | None = None,\n    fields: Iterable[str] | None = None,\n) -&gt; SobjectGetSubrequest:\n    \"\"\"\n    Get record by ID or external ID.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n        E.g. \"Account\", \"Contact\", etc.\n    id_ : str\n        Salesforce record ID or external ID (if external_id_field is provided).\n    external_id_field : str, optional\n        External ID field name, by default None.\n    fields : Iterable[str], optional\n        Fields to get for the record.\n        By default returns all fields.\n\n    Returns\n    -------\n    SobbjectGetSubrequest\n        Get subrequest.\n        Record can be accessed via the `record` property.\n\n    \"\"\"\n    url = httpx.URL(\n        \"/\".join(\n            [\n                self.base_path,\n                sobject,\n                id_ if external_id_field is None else f\"{external_id_field}/{id_}\",\n            ]\n        )\n    )\n    if fields is not None:\n        url = url.copy_add_param(\"fields\", \",\".join(fields))\n    subrequest = SobjectGetSubrequest(\n        self.composite_request.get_reference_id(f\"{sobject}_get\"),\n        \"GET\",\n        str(url),\n    )\n    self.composite_request.add_subrequest(subrequest)\n    return subrequest\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.SobjectSubrequestClient.update","title":"<code>update(sobject, id_, /, data)</code>","text":"<p>Update record by ID.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name. E.g. \"Account\", \"Contact\", etc.</p> required <code>id_</code> <code>str</code> <p>Salesforce record ID.</p> required <code>data</code> <code>dict | str | bytes | bytearray</code> <p>Data to update the record with. Either a dict or a JSON string/bytes representing a dict.</p> required <p>Returns:</p> Type Description <code>Subrequest</code> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>def update(\n    self,\n    sobject: str,\n    id_: str,\n    /,\n    data: dict | str | bytes | bytearray,\n) -&gt; Subrequest:\n    \"\"\"\n    Update record by ID.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n        E.g. \"Account\", \"Contact\", etc.\n    id_ : str\n        Salesforce record ID.\n    data : dict | str | bytes | bytearray\n        Data to update the record with.\n        Either a dict or a JSON string/bytes representing a dict.\n\n    Returns\n    -------\n    Subrequest\n\n    \"\"\"\n    subrequest = Subrequest(\n        self.composite_request.get_reference_id(f\"{sobject}_update\"),\n        \"PATCH\",\n        f\"{self.base_path}/{sobject}/{id_}\",\n        body=data if isinstance(data, dict) else json_loads(data),\n    )\n    self.composite_request.add_subrequest(subrequest)\n    return subrequest\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.SobjectSubrequestClient.delete","title":"<code>delete(sobject, id_, /, external_id_field=None)</code>","text":"<p>Delete record by ID.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name. E.g. \"Account\", \"Contact\", etc.</p> required <code>id_</code> <code>str</code> <p>Salesforce record ID or external ID (if external_id_field is provided).</p> required <code>external_id_field</code> <code>str</code> <p>External ID field name. If not provided, id_ is treated as a record ID.</p> <code>None</code> <p>Returns:</p> Type Description <code>Subrequest</code> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>def delete(\n    self,\n    sobject: str,\n    id_: str,\n    /,\n    external_id_field: str | None = None,\n) -&gt; Subrequest:\n    \"\"\"\n    Delete record by ID.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n        E.g. \"Account\", \"Contact\", etc.\n    id_ : str\n        Salesforce record ID or external ID (if external_id_field is provided).\n    external_id_field : str, optional\n        External ID field name.\n        If not provided, id_ is treated as a record ID.\n\n    Returns\n    -------\n    Subrequest\n\n    \"\"\"\n    url = f\"{self.base_path}/{sobject}\"\n    if external_id_field is None:\n        url += f\"/{id_}\"\n    else:\n        url += f\"/{external_id_field}/{id_}\"\n    subrequest = Subrequest(\n        self.composite_request.get_reference_id(f\"{sobject}_delete\"),\n        \"DELETE\",\n        url,\n    )\n    self.composite_request.add_subrequest(subrequest)\n    return subrequest\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.SobjectSubrequestClient.upsert","title":"<code>upsert(sobject, id_, /, external_id_field, data, validate=True)</code>","text":"<p>Upsert (update if exists, create if not) record by external ID.</p> <p>Parameters:</p> Name Type Description Default <code>sobject</code> <code>str</code> <p>Salesforce object name. E.g. \"Account\", \"Contact\", etc.</p> required <code>id_</code> <code>str</code> <p>Salesforce record external ID.</p> required <code>external_id_field</code> <code>str</code> <p>External ID field name.</p> required <code>data</code> <code>dict | str | bytes | bytearray</code> <p>Data to upsert the record with. Either a dict or a JSON string/bytes representing a dict.</p> required <code>validate</code> <code>bool</code> <p>If True, validates the request and removes the external ID field from the data if it's present. By default True. The reason for this is that Salesforce does not allow payload to contain an external ID field when upserting on it. Set this to False if you know you data is correct and you want to improve performance.</p> <code>True</code> <p>Returns:</p> Type Description <code>SobjectUpsertSubrequest</code> <p>Upsert subrequest. Exposes 'id' and 'created' properties.</p> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>def upsert(\n    self,\n    sobject: str,\n    id_: str,\n    /,\n    external_id_field: str,\n    data: dict | str | bytes | bytearray,\n    validate: bool = True,\n) -&gt; SobjectUpsertSubrequest:\n    \"\"\"\n    Upsert (update if exists, create if not) record by external ID.\n\n    Parameters\n    ----------\n    sobject : str\n        Salesforce object name.\n        E.g. \"Account\", \"Contact\", etc.\n    id_ : str\n        Salesforce record external ID.\n    external_id_field : str\n        External ID field name.\n    data : dict | str | bytes | bytearray\n        Data to upsert the record with.\n        Either a dict or a JSON string/bytes representing a dict.\n    validate : bool, default True\n        If True, validates the request and removes the external ID field\n        from the data if it's present. By default True.\n        The reason for this is that Salesforce does not allow\n        payload to contain an external ID field when upserting on it.\n        Set this to False if you know you data is correct and\n        you want to improve performance.\n\n    Returns\n    -------\n    SobjectUpsertSubrequest\n        Upsert subrequest.\n        Exposes 'id' and 'created' properties.\n\n    \"\"\"\n    if validate:\n        if isinstance(data, (str, bytes, bytearray)):\n            data = json_loads(data)\n        else:\n            # Copy payload to avoid mutating the original\n            data = json_loads(json_dumps(data))\n        if not isinstance(data, dict):\n            raise TypeError(\n                f\"data must be a dict, str, bytes, or bytearray, \"\n                f\"got {type(data).__name__}\"\n            )\n        try:\n            if str(data[external_id_field]) != str(id_):\n                raise ValueError(\n                    f\"External ID field '{external_id_field}' in data \"\n                    f\"{data[external_id_field]} does not match \"\n                    f\"the provided external id '{id_}'\"\n                )\n            data.pop(external_id_field)\n        except KeyError:\n            pass\n\n    subrequest = SobjectUpsertSubrequest(\n        self.composite_request.get_reference_id(f\"{sobject}_upsert\"),\n        \"PATCH\",\n        f\"{self.base_path}/{sobject}/{external_id_field}/{id_}\",\n        body=data if isinstance(data, dict) else json_loads(data),\n    )\n    self.composite_request.add_subrequest(subrequest)\n    return subrequest\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.CompositeRequest","title":"<code>CompositeRequest</code>","text":"<p>Composite request.</p> <p>Parameters:</p> Name Type Description Default <code>salesforce_client</code> <code>Salesforce</code> <p>Salesforce client.</p> required <code>all_or_none</code> <code>bool</code> <p>If True, all subrequests are rolled back if any subrequest fails.</p> <code>False</code> <code>collate_subrequests</code> <code>bool</code> <p>If True, independent subrequests are executed by Salesforce in parallel.</p> <code>True</code> <code>autoraise</code> <code>bool</code> <p>If True, raises an ExceptionGroup if any subrequest fails.</p> <code>False</code> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>class CompositeRequest:\n    \"\"\"\n    Composite request.\n\n    Parameters\n    ----------\n    salesforce_client : Salesforce\n        Salesforce client.\n    all_or_none : bool, default False\n        If True, all subrequests are rolled back if any subrequest fails.\n    collate_subrequests : bool, default True\n        If True, independent subrequests are executed by Salesforce in parallel.\n    autoraise : bool, default False\n        If True, raises an ExceptionGroup if any subrequest fails.\n\n    \"\"\"\n\n    salesforce_client: \"Salesforce\"\n    all_or_none: bool\n    collate_subrequests: bool\n    autoraise: bool\n\n    __subrequests: dict[str, Subrequest]\n    __ref_counters: dict[str, itertools.count]\n\n    def __init__(\n        self,\n        salesforce_client: \"Salesforce\",\n        all_or_none: bool = False,\n        collate_subrequests: bool = True,\n        autoraise: bool = False,\n    ) -&gt; None:\n        self.salesforce_client = salesforce_client\n        self.all_or_none = all_or_none\n        self.collate_subrequests = collate_subrequests\n        self.autoraise = autoraise\n\n        self.__subrequests = {}\n        self.__ref_counters = {}\n\n    def get_reference_id(self, name: str) -&gt; str:\n        \"\"\"\n        Get a unique reference ID for a subrequest.\n\n        Parameters\n        ----------\n        name : str\n            Subrequest name.\n            E.g. 'Query' or 'Contact_create'.\n\n        Returns\n        -------\n        str\n            Unique reference ID.\n            E.g., 'Query_0' or 'Contact_create_3'.\n\n        \"\"\"\n        counter = self.__ref_counters.setdefault(name.lower(), itertools.count())\n        return f\"{name}_{next(counter)}\"\n\n    def add_subrequest(self, subrequest: Subrequest) -&gt; None:\n        if subrequest.reference_id in self.__subrequests:\n            raise ValueError(\n                f\"Reference ID '{subrequest.reference_id}' is already in use.\"\n            )\n        self.__subrequests[subrequest.reference_id] = subrequest\n\n    async def execute(self) -&gt; None:\n        \"\"\"Execute composite request and set subrequests' responses.\"\"\"\n        if len(self.__subrequests) == 0:\n            return\n        response = await self.salesforce_client.request(\n            \"POST\",\n            \"/\".join(\n                [\n                    self.salesforce_client.base_url,\n                    \"services\",\n                    \"data\",\n                    f\"v{self.salesforce_client.version}\",\n                    \"composite\",\n                ]\n            ),\n            content=json_dumps(\n                {\n                    \"allOrNone\": self.all_or_none,\n                    \"collateSubrequests\": self.collate_subrequests,\n                    \"compositeRequest\": [\n                        subrequest.to_dict()\n                        for subrequest in self.__subrequests.values()\n                    ],\n                }\n            ),\n            headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n        )\n        for subrequest, subrequest_response in zip(\n            self.__subrequests.values(),\n            # Salesforce escapes characters in Composite JSON response as if it was HTML\n            json_loads(unescape(response.content.decode(\"utf-8\")))[\"compositeResponse\"],\n        ):\n            subrequest.response = subrequest_response\n        if self.autoraise:\n            errors: list[Exception] = []\n            for subrequest in self.__subrequests.values():\n                try:\n                    subrequest.raise_for_status()\n                except Exception as exc:\n                    errors.append(exc)\n            if len(errors) &gt; 0:\n                raise ExceptionGroup(\"Composite request error\", errors)\n\n    async def __aenter__(self) -&gt; \"CompositeRequest\":\n        return self\n\n    async def __aexit__(self, exc_type, exc, tb) -&gt; None:\n        # Execute only if no exception occurred\n        if exc is None:\n            await self.execute()\n\n    def query(self, query: str, include_all_records: bool = False) -&gt; QuerySubrequest:\n        \"\"\"\n        Execute a SOQL query.\n\n        Parameters\n        ----------\n        query : str\n            SOQL query.\n        include_all_records : bool, default False\n            If True, includes all (active/deleted/archived) records.\n\n        Returns\n        -------\n        QuerySubrequest\n            Query subrequest.\n            Records can be accessed via the `records` property.\n\n        \"\"\"\n        url = httpx.URL(\n            \"/\".join(\n                [\n                    \"\",\n                    \"services\",\n                    \"data\",\n                    f\"v{self.salesforce_client.version}\",\n                    \"query\" if not include_all_records else \"queryAll\",\n                ]\n            )\n        ).copy_add_param(\"q\", query)\n        reference_id = self.get_reference_id(\"Query\")\n        subrequest = QuerySubrequest(reference_id, \"GET\", str(url))\n        self.add_subrequest(subrequest)\n        return subrequest\n\n    @cached_property\n    def sobject(self) -&gt; SobjectSubrequestClient:\n        \"\"\"Perform sObject operations.\"\"\"\n        return SobjectSubrequestClient(self)\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.CompositeRequest.sobject","title":"<code>sobject: SobjectSubrequestClient</code>  <code>cached</code> <code>property</code>","text":"<p>Perform sObject operations.</p>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.CompositeRequest.get_reference_id","title":"<code>get_reference_id(name)</code>","text":"<p>Get a unique reference ID for a subrequest.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Subrequest name. E.g. 'Query' or 'Contact_create'.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Unique reference ID. E.g., 'Query_0' or 'Contact_create_3'.</p> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>def get_reference_id(self, name: str) -&gt; str:\n    \"\"\"\n    Get a unique reference ID for a subrequest.\n\n    Parameters\n    ----------\n    name : str\n        Subrequest name.\n        E.g. 'Query' or 'Contact_create'.\n\n    Returns\n    -------\n    str\n        Unique reference ID.\n        E.g., 'Query_0' or 'Contact_create_3'.\n\n    \"\"\"\n    counter = self.__ref_counters.setdefault(name.lower(), itertools.count())\n    return f\"{name}_{next(counter)}\"\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.CompositeRequest.execute","title":"<code>execute()</code>  <code>async</code>","text":"<p>Execute composite request and set subrequests' responses.</p> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>async def execute(self) -&gt; None:\n    \"\"\"Execute composite request and set subrequests' responses.\"\"\"\n    if len(self.__subrequests) == 0:\n        return\n    response = await self.salesforce_client.request(\n        \"POST\",\n        \"/\".join(\n            [\n                self.salesforce_client.base_url,\n                \"services\",\n                \"data\",\n                f\"v{self.salesforce_client.version}\",\n                \"composite\",\n            ]\n        ),\n        content=json_dumps(\n            {\n                \"allOrNone\": self.all_or_none,\n                \"collateSubrequests\": self.collate_subrequests,\n                \"compositeRequest\": [\n                    subrequest.to_dict()\n                    for subrequest in self.__subrequests.values()\n                ],\n            }\n        ),\n        headers={\"Content-Type\": \"application/json\", \"Accept\": \"application/json\"},\n    )\n    for subrequest, subrequest_response in zip(\n        self.__subrequests.values(),\n        # Salesforce escapes characters in Composite JSON response as if it was HTML\n        json_loads(unescape(response.content.decode(\"utf-8\")))[\"compositeResponse\"],\n    ):\n        subrequest.response = subrequest_response\n    if self.autoraise:\n        errors: list[Exception] = []\n        for subrequest in self.__subrequests.values():\n            try:\n                subrequest.raise_for_status()\n            except Exception as exc:\n                errors.append(exc)\n        if len(errors) &gt; 0:\n            raise ExceptionGroup(\"Composite request error\", errors)\n</code></pre>"},{"location":"api-reference/composite/composite/#aiosalesforce.composite.composite.CompositeRequest.query","title":"<code>query(query, include_all_records=False)</code>","text":"<p>Execute a SOQL query.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>SOQL query.</p> required <code>include_all_records</code> <code>bool</code> <p>If True, includes all (active/deleted/archived) records.</p> <code>False</code> <p>Returns:</p> Type Description <code>QuerySubrequest</code> <p>Query subrequest. Records can be accessed via the <code>records</code> property.</p> Source code in <code>src/aiosalesforce/composite/composite.py</code> <pre><code>def query(self, query: str, include_all_records: bool = False) -&gt; QuerySubrequest:\n    \"\"\"\n    Execute a SOQL query.\n\n    Parameters\n    ----------\n    query : str\n        SOQL query.\n    include_all_records : bool, default False\n        If True, includes all (active/deleted/archived) records.\n\n    Returns\n    -------\n    QuerySubrequest\n        Query subrequest.\n        Records can be accessed via the `records` property.\n\n    \"\"\"\n    url = httpx.URL(\n        \"/\".join(\n            [\n                \"\",\n                \"services\",\n                \"data\",\n                f\"v{self.salesforce_client.version}\",\n                \"query\" if not include_all_records else \"queryAll\",\n            ]\n        )\n    ).copy_add_param(\"q\", query)\n    reference_id = self.get_reference_id(\"Query\")\n    subrequest = QuerySubrequest(reference_id, \"GET\", str(url))\n    self.add_subrequest(subrequest)\n    return subrequest\n</code></pre>"},{"location":"api-reference/composite/exceptions/","title":"Exceptions","text":""},{"location":"api-reference/composite/exceptions/#aiosalesforce.composite.exceptions.CompositeError","title":"<code>CompositeError</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Base class for all Composite API exceptions.</p> Source code in <code>src/aiosalesforce/composite/exceptions.py</code> <pre><code>class CompositeError(Exception):\n    \"\"\"Base class for all Composite API exceptions.\"\"\"\n</code></pre>"},{"location":"api-reference/composite/exceptions/#aiosalesforce.composite.exceptions.InvalidStateError","title":"<code>InvalidStateError</code>","text":"<p>             Bases: <code>CompositeError</code></p> <p>Raised when subrequest or node is in an invalid state for attempted operation.</p> Source code in <code>src/aiosalesforce/composite/exceptions.py</code> <pre><code>class InvalidStateError(CompositeError):\n    \"\"\"Raised when subrequest or node is in an invalid state for attempted operation.\"\"\"\n</code></pre>"},{"location":"documentation/authentication/","title":"Authentication","text":""},{"location":"documentation/authentication/#overview","title":"Overview","text":"<p>Before you can make requests to the Salesforce API, you need to authenticate In <code>aiosalesforce</code> authentication is a dependency you provide to the <code>Salesforce</code> client. The typical usage pattern looks like this (using the <code>SoapLogin</code> authentication method as an example):</p> <pre><code>import asyncio\n\nfrom aiosalesforce import Salesforce, SoapLogin\nfrom httpx import AsyncClient\n\nauth = SoapLogin(\n    username=\"username\",\n    password=\"password\",\n    security_token=\"security-token\",\n)\n\n\nasync def main():\n    async with AsyncClient() as client:\n        salesforce = Salesforce(\n            client=client,\n            base_url=\"https://your-instance.my.salesforce.com\",\n            auth=auth,\n        )\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Best Practice</p> <p>Always declare your authentication instance as a global variable and reuse it across your application. You can have many clients using the same authentication instance. By doing so, you can avoid unnecessary re-authentication and reduce the number of requests to the Salesforce API.</p> <p>Warning</p> <p>Keep your credentials safe and never hardcode them in your application. Use third-party libraries to acquire credentials from environment variables, configuration files, or secret management services during runtime.</p>"},{"location":"documentation/authentication/#built-in-authentication-methods","title":"Built-in Authentication Methods","text":"Method Connected App Server-to-Server SOAP Login Client Credentials Flow JWT Bearer Flow"},{"location":"documentation/authentication/#soap-login","title":"SOAP Login","text":"<p>Authenticate using <code>username</code>, <code>password</code>, and <code>security token</code>.</p> <pre><code>from aiosalesforce import SoapLogin\n\nauth = SoapLogin(\n    username=\"username\",\n    password=\"password\",\n    security_token=\"security-token\",\n)\n</code></pre> Where to find security token? <p>Security token can be obtained from the Salesforce UI by navigating to <code>Settings</code> &gt; <code>Personal Information</code> &gt; <code>Reset My Security Token</code>, clicking the <code>Reset Security Token</code> button, and then checking your email for the new token.</p> <p> When you update security token make sure to update all applications which are using the old token for this user.</p>"},{"location":"documentation/authentication/#client-credentials-flow","title":"Client Credentials Flow","text":"<p>Authenticate using a connected app for server-to-server integrations.</p> <pre><code>from aiosalesforce import ClientCredentials\n\nauth = ClientCredentials(\n    client_id=\"client-id\",\n    client_secret=\"client-secret\",\n)\n</code></pre> How to create and configure a connected app? <p>First, you need to creat a connected app in Salesforce:</p> <ol> <li>Navigate to <code>Setup</code> &gt; <code>Apps</code> &gt; <code>App Manager</code> and click <code>New Connected App</code></li> <li>Check <code>Enable OAuth Settings</code></li> <li>Check <code>Enable for Device Flow</code></li> <li>Check <code>Enable Client Credentials Flow</code></li> <li>Select necessary scopes (generally, it's <code>Full access (full)</code>)</li> </ol> <p>Next, you need to enable the Client Credentials Flow for the connected app:</p> <ol> <li>Navigate to <code>Setup</code> &gt; <code>Apps</code> &gt; <code>App Manager</code> and find your connected app</li> <li>Click <code>Manage</code> and then <code>Edit Policies</code></li> <li>Select <code>All users may self-authorize</code> in the <code>Permitted Users</code> section</li> <li>Select a user on behalf of which the connected app will authenticate and    perform actions in the <code>Run As</code> field of the <code>Client Credentials Flow</code> section</li> <li>(optional) Set the <code>Timeout Value</code> field to whichever value is appropriate in    your case</li> <li>Click <code>Save</code></li> </ol> <p>Finally, you need to retrieve the <code>client_id</code> and <code>client_secret</code> for the connected app:</p> <ol> <li>Navigate to <code>Setup</code> &gt; <code>Apps</code> &gt; <code>App Manager</code> and find your connected app</li> <li>Click <code>View</code> and then click <code>Manage Consumer Details</code></li> <li>Copy the <code>Consumer Key</code> (<code>client_id</code>) and <code>Consumer Secret</code> (<code>client_secret</code>)    values. If you need to reset your credentials, you do it here as well.</li> </ol> <p>If you configured timeout for the access token when creating the connected app, you can use the <code>timeout</code> parameter to specify duration in seconds after which the access token will be automatically refreshed. This way you can save a retry API call which would normally be retried due to 401 (token expired) by pre-emptively refreshing the token.</p> <pre><code>auth = ClientCredentials(\n    client_id=\"client-id\",\n    client_secret=\"client-secret\",\n    timeout=900,  # 15 minutes\n)\n</code></pre>"},{"location":"documentation/authentication/#jwt-bearer-flow","title":"JWT Bearer Flow","text":"<p>Authenticate using connected app and RSA private key.</p> <pre><code>from aiosalesforce import JwtBearerFlow\n\nauth = JwtBearerFlow(\n    client_id=\"client-id\",\n    username=\"username\",\n    private_key=\"path/to/private-key.pem\",\n)\n</code></pre> <p>Where:</p> <ul> <li><code>client_id</code> is the connected app's consumer key</li> <li><code>username</code> is the username of the user on behalf of which the connected app will   authenticate and perform actions</li> <li><code>private_key</code> is the path to the RSA private key file (must be in PEM format)</li> </ul> <p>You can optionally provide <code>private_key_passphrase</code> (if the private key is encrypted) and <code>timeout</code> (if you set connected app timeout) parameters.</p> <p>Warning</p> <p>The JWT Bearer Flow requires <code>PyJWT</code> and <code>cryptography</code> libraries to be installed. You can install them using <code>pip install aiosalesforce[jwt]</code>.</p> How to configure a connected app to use JWT Bearer Flow? <p>Follow the same steps as for the Client Credentials Flow to create a connected app.</p> <p>Create certificate and download certificate:</p> <ol> <li>Navitate to <code>Setup</code> &gt; <code>Security</code> &gt; <code>Certificate and Key Management</code></li> <li>Click <code>Create Self-Signed Certificate</code>, give it label, name, select key size,    check <code>Exportable Private Key</code>, and click <code>Save</code></li> <li>Navigate back to <code>Certificate and Key Management</code> and click on    <code>Export to Keystore</code> (password needs to contain special characters, otherwise    Salesforce will tell you that you don't have sufficient privileges). Password    is needed only to subsequently extract the private key so you can discard it    after you are done with the process.</li> <li>Click <code>Export</code> and save it locally (e.g. <code>certificate.crt</code>)</li> </ol> <p>Extract private key:</p> <ol> <li>Run the following command to extract the private key from the keystore:    <pre><code>keytool -importkeystore -srckeystore certificate.crt -destkeystore \\\ncertificate.p12 -deststoretype PKCS12\n</code></pre>    Enter password when prompted</li> <li>Run the following command to extract the private key from the PKCS12 file:    <pre><code>openssl pkcs12 -in certificate.p12 -nocerts -nodes -out private-key.pem\n</code></pre>    The <code>private-key.pem</code> file is your RSA private key</li> </ol> <p>Connected app needs additional configuration to use JWT Bearer Flow:</p> <ol> <li>Navigate to <code>Setup</code> &gt; <code>Apps</code> &gt; <code>App Manager</code> and find your connected app</li> <li>Click <code>Manage</code> and then click <code>Edit Policies</code></li> <li>Under <code>Permitted Users</code>, select <code>Admin approved users are pre-authorized</code></li> <li><code>Save</code></li> <li>Navigate to <code>Setup</code> &gt; <code>Apps</code> &gt; <code>App Manager</code>, find your connected app,    and click <code>Edit</code></li> <li>Check <code>Use digital signatures</code> and upload the certificate (<code>certificate.crt</code>)    you created and downloaded from Salesforce earlier</li> <li><code>Save</code></li> </ol> <p>Update profile assigned to user(s) configured for this connected app:</p> <ol> <li>Navigate to <code>Setup</code> &gt; <code>Users</code> &gt; <code>Profiles</code></li> <li>Find profile assigned to the user (or create a new one) and click <code>Edit</code></li> <li>Enable <code>Connected App Access</code> for the connected app you created</li> </ol>"},{"location":"documentation/authentication/#custom-authentication","title":"Custom Authentication","text":"<p>You can create a custom authentication class by subclassing the <code>Auth</code> class.</p> <p>You must implement the <code>_acquire_new_access_token</code> method which is responsible for acquiring a new access token. This doesn't mean that you have to acquire a new access token from Salesforce - only that calling this method should return a new access token each time it is called. Examples of behavior:</p> <ul> <li>Fetch new token directly from Salesforce</li> <li>Fetch token from some service (e.g., centralized authentication service)</li> <li>Fetch token from cache and, if cache is empty/expired, fetch new token from Salesforce   and update cache</li> </ul> <p>You can optionally implement the <code>_refresh_access_token</code> method which is responsible for refreshing the access token. If you don't implement this method, the <code>_acquire_new_access_token</code> method will be called instead.</p> <p>You can implement expiration mechanism by implementing the <code>expired</code> property in your custom authentication class. This property should return a boolean value indicating whether the access token has expired. Auth class will call the <code>_refresh_access_token</code> method when the access token expires. By default the <code>expired</code> property always returns <code>False</code>. You can declare whatever class attributes you need to implement the expiration mechanism.</p> <p>Information</p> <p>When implementing custom authentication, you are responsible for emitting <code>RequestEvent</code> and <code>ResponseEvent</code> events using <code>client.event_bus.publish_event</code> method. If you don't do this, any client-side logic built around events (e.g., logging or metrics) will not receive request/response information related to authentication.</p> <pre><code>from aiosalesforce.auth import Auth\n\n\nclass MyAuth(Auth):\n    def __init__(\n        self,\n        # Your custom arguments\n        ...\n    ):\n        super().__init__()\n        # Your custom initialization logic\n        ...\n\n    async def _acquire_new_access_token(self, client: Salesforce) -&gt; str:\n        # Your custom logic to acquire new access token\n        ...\n\n    async def _refresh_access_token(self, client: Salesforce) -&gt; str:\n        # Your custom logic to refresh access token\n        ...\n\n    @property\n    def expired(self) -&gt; bool:\n        super().expired\n        # Your custom logic to check if access token has expired\n        ...\n</code></pre> <p>Warning</p> <p>You must follow these rules when making HTTP requests from your custom authentication class:</p> <ul> <li>Requets to Salesforce must be made using the   <code>client.retry_policy.send_request_with_retries</code> method</li> <li>Requests to other services must be made using the   <code>client.httpx_client</code> attribute</li> </ul> <p>Under no circumstances should you make HTTP requests using the <code>client.request</code> method - this method calls authentication methods and can lead to infinite recursion.</p> <p>You can request any arguments in the <code>__init__</code> method of your custom authentication class. The <code>__init__</code> method must call the <code>super().__init__()</code> method to initialize the base class. After that, you can declare whatever attributes and methods you need.</p>"},{"location":"documentation/client/","title":"Salesforce Client","text":""},{"location":"documentation/client/#overview","title":"Overview","text":"<p>When working with <code>aiosalesforce</code> you will always start by creating a <code>Salesforce</code> client. The minimum required parameters are:</p> <ul> <li><code>client</code> - an instance of <code>httpx.AsyncClient</code> used to make HTTP requests</li> <li><code>base_url</code> - URL of your Salesforce instance. Examples of valid URLs are:</li> <li><code>auth</code> - you need to provide credentials for your Salesforce instance</li> </ul> <pre><code>from aiosalesforce import Salesforce, SoapLogin\nfrom httpx import AsyncClient\n\nauth = SoapLogin(\n    username=\"username\",\n    password=\"password\",\n    security_token=\"security-token\",\n)\n\nasync def main():\n    async with AsyncClient() as client:\n        salesforce = Salesforce(\n            client=client,\n            base_url=\"https://your-instance.my.salesforce.com\",\n            auth=auth,\n        )\n\n        # Your code here\n        ...\n</code></pre> <p>Note</p> <p>Base URL can be any URL that points to your Salesforce instance login page, which ends with <code>.my.salesforce.com</code>. Depending on the type of your Salesforce instance, the URL will have this structure:</p> <ul> <li>Production : <code>https://[MyDomainName].my.salesforce.com</code></li> <li>Sandbox : <code>https://[MyDomainName]-[SandboxName].sandbox.my.salesforce.com</code></li> <li>Developer org : <code>https://[MyDomainName].develop.my.salesforce.com</code></li> </ul> <p>Everything after <code>.my.salesforce.com</code> is ignored, so you can pass any URL that begins with one of the patterns above. For example, a URL like <code>https://acme.my.salesforce.com/any/path?or=query</code> would be perfectly valid.</p> <p>You can specify the version of the Salesforce API you want to use via the <code>version</code> parameter. The default value is the latest version at the time of the library release.</p> <pre><code>salesforce = Salesforce(\n    client=client,\n    base_url=\"https://your-instance.my.salesforce.com\",\n    auth=auth,\n    version=\"52.0\",\n)\n</code></pre> <p>Valid version values looks like <code>XX</code>, <code>XX.</code>, <code>XX.0</code>, <code>vXX</code>, <code>vXX.</code>, <code>vXX.0</code>, where <code>XX</code> is a number. For example, <code>52.0</code> is a valid version but <code>52.1</code> is not.</p>"},{"location":"documentation/client/#event-hooks","title":"Event Hooks","text":"<p>When you use the <code>Salesforce</code> client, it emits certain events to which you can subscribe. This allows you to perform custom actions at different stages of the request-response lifecycle. For example, you can log requests and responses, monitor retries, or track usage of different Salesforce APIs within your application.</p> <p>To subscribe to events, you need to define a callback function and then pass it to the <code>Salesforce</code> client. The callback function will be called when an event is emitted. The callback function will receive an event object as the only argument and will not return anything (any return value will be ignored by the client).</p> <pre><code>async def callback(event):\n    # Do something with the event\n    ...\n</code></pre> <p>Once you have defined your callback functions, you can pass them to the <code>Salesforce</code> client using the <code>event_hooks</code> parameter.</p> <pre><code>salesforce = Salesforce(\n    ...,\n    event_hooks=[callback, ...],\n)\n</code></pre> <p>You can also add or remove callbacks after the client has been created using the <code>subscribe_callback</code> and <code>unsubscribe_callback</code> methods of the <code>event_bus</code> attribute of the <code>Salesforce</code> client.</p> <pre><code>salesforce.event_bus.subscribe_callback(callback)\nsalesforce.event_bus.unsubscribe_callback(callback)\n</code></pre> <p>Note</p> <p>Event hooks are executed concurrently and are not guaranteed to be called in the order they were added. Do not rely on the order of execution of your callback functions. If you need to perform certain operations in a specific order, declare them within the same callback function.</p>"},{"location":"documentation/client/#events","title":"Events","text":"<p>All events emitted by the <code>Salesforce</code> client are instances of the <code>Event</code> class. You can determine the type of event by checking the <code>type</code> attribute of the event or by checking the type of the event object.</p> Event <code>type</code> When emitted Attributes <code>RequestEvent</code> <code>request</code> Before making a request to the Salesforce API <code>request</code> <code>RetryEvent</code> <code>retry</code> Before request is retried. Depending on the cause, has either <code>response</code> or <code>exception</code> attributes <code>request</code>, <code>attempt</code>, <code>response</code> (optional), <code>exception</code> (optional) <code>ResponseEvent</code> <code>response</code> After an OK (status code &lt; 300) response is received <code>response</code> <code>RestApiCallConsumptionEvent</code> <code>rest_api_call_consumption</code> When a Salesforce API call is consumed (includes unsuccessful requests) <code>response</code>, <code>count</code> <code>BulkApiBatchConsumptionEvent</code> <code>bulk_api_batch_consumption</code> When a Bulk API (v1 or v2) batch is consumed <code>response</code>, <code>count</code> <p>Note</p> <p>The <code>attempt</code> attribute of the <code>RetryEvent</code> indicates sequential number of the retry attempt. The first retry attempt is <code>1</code>, the second is <code>2</code>, and so on. Attempt <code>0</code> is the initial request and is not a retry.</p> <p>Note</p> <p>All events which have the <code>response</code> attribute will contain <code>consumed</code> and <code>remaining</code> attributes. The <code>consumed</code> attribute is the number of API calls consumed and the <code>remaining</code> attribute is the number of API calls remaining in the current 24-hour period. Not all responses will have this information (for example, authentication responses) - in such cases, these attributes will have value <code>None</code>.</p> <p>Warning</p> <p><code>BulkApiBatchConsumptionEvent</code> is best-effort and is not guaranteed to accurately reflect the number of consumed batches when using Bulk API 2.0. This is because Salesforce does not provide a way to track the number of consumed batches and <code>aiosalesforce</code> uses heuristics to estimate the number of consumed batches.</p>"},{"location":"documentation/client/#callback-function","title":"Callback Function","text":"<p>The callback function will receive an event object as the only argument. You cannot specify what type of event you want to subscribe to - your callback function will receive all events emitted by the <code>Salesforce</code> client. You are responsible for filtering out events you are not interested in.</p> <p>Using the <code>type</code> attribute:</p> <pre><code>from aiosalesforce import Event\n\nasync def callback(event: Event) -&gt; None:\n    match event.type:\n        case \"request\":\n            # Do something with the request event\n            ...\n        case \"response\":\n            # Do something with the response event\n            ...\n        case _:\n            # Do nothing for other events\n            pass\n</code></pre> <p>Using the type of the event object:</p> <pre><code>from aiosalesforce import RequestEvent, ResponseEvent\n\ndef callback(event) -&gt; None:\n    match event:\n        case RequestEvent():\n            # Do something with the request event\n            ...\n        case ResponseEvent():\n            # Do something with the response event\n            ...\n        case _:\n            # Do nothing for other events\n            pass\n</code></pre> <p>Warning</p> <p>Only use <code>async def</code> if your callback function is asynchronous. If it contains synchronous network calls, it will slow down the entire application by blocking the event loop. If you need to perform synchronous operations, declare your function as a regular function using <code>def</code> - such functions will be run in a separate thread to avoid blocking the event loop. You can mix asynchronous and synchronous functions when using event hooks - <code>aiosalesforce</code> will use an appropriate concurrency model for each of your callback functions.</p>"},{"location":"documentation/client/#examples","title":"Examples","text":""},{"location":"documentation/client/#keep-track-of-api-usage","title":"Keep Track of API Usage","text":"<p>An example below shows how you can use event hooks to keep track of the number of requests made to the Salesforce API. This can be useful if you want to record and monitor your API usage over time. For example, you can use send usage metrics to a metrics service like AWS CloudWatch.</p> <pre><code>from aiosalesforce import (\n    Event,\n    BulkApiBatchConsumptionEvent,\n    RestApiCallConsumptionEvent,\n)\n\n\ndef track_api_usage(event: Event):\n    match event:\n        case RestApiCallConsumptionEvent():\n            my_metrics_service.put_metric_data(\n                Namespace=\"Salesforce\",\n                MetricData=[\n                    {\n                        \"MetricName\": \"Salesforce REST API Call Count\",\n                        \"Value\": event.count,\n                        \"Unit\": \"Count\",\n                    },\n                ],\n            )\n        case BulkApiBatchConsumptionEvent():\n            my_metrics_service.put_metric_data(\n                Namespace=\"Salesforce\",\n                MetricData=[\n                    {\n                        \"MetricName\": \"Salesforce Bulk API Batch Count\",\n                        \"Value\": event.count,\n                        \"Unit\": \"Count\",\n                    },\n                ],\n            )\n\n\nsalesforce.event_bus.subscribe_callback(track_api_usage)\n</code></pre>"},{"location":"documentation/client/#log-retries","title":"Log Retries","text":"<pre><code>from aiosalesforce import Event, RetryEvent\n\n\nasync def log_retries(event: Event):\n    match event:\n        case RetryEvent():\n            print(\n                f\"Retrying {event.request.method} request to {event.request.url} \"\n                f\"due to: {event.response or type(event.exception).__name__}. \"\n                f\"This is attempt {event.attempt}\"\n            )\n\n\nsalesforce.event_bus.subscribe_callback(log_retries)\n</code></pre>"},{"location":"documentation/client/#log-requests","title":"Log Requests","text":"<pre><code>from aiosalesforce import Event, RequestEvent\n\n\nasync def log_requests(event: Event):\n    match event:\n        case RequestEvent():\n            logger.info(\"%s %s\", event.request.method, event.request.url)\n\n\nsalesforce.event_bus.subscribe_callback(log_requests)\n</code></pre>"},{"location":"documentation/client/#best-practices","title":"Best Practices","text":"<ul> <li>Use asynchronous functions if you make asynchronous IO operations and synchronous   functions if you make synchronous IO operations in your callback.</li> <li>Use the <code>match</code> or <code>if</code> statements to filter out events you are not interested in.</li> <li>Declare one callback for each operation you want to perform. This will make   your code simpler to understand and may make it run faster if you have IO operations   inside your callbacks.</li> </ul>"},{"location":"documentation/client/#retrying-requests","title":"Retrying Requests","text":"<p>You can configure the <code>Salesforce</code> client to automatically retry requests that fail for various reasons. This can be useful for handling transient errors which are expected to succeed under normal circumstances. For example, you may want to retry server errors caued by temporary instabilities in a Salesforce processing node working on your request.</p> <p>You can control the retry behavior by passing a <code>RetryPolicy</code> instance to the <code>retry_policy</code> parameter of the <code>Salesforce</code> client. A <code>RetryPolicy</code> instance defines the conditions under which a request should be retried, how many times it should be retried, and how long to wait between retries.</p> <pre><code>from aiosalesforce import RetryPolicy, ExceptionRule, ResponseRule\n\nretry_policy = RetryPolicy(\n    response_rules=[\n        ResponseRule(lambda response: response.status_code &gt;= 500, max_retries=5),\n        ResponseRule(lambda response: \"UNABLE_TO_LOCK_ROW\" in response.text),\n    ],\n    exception_rules=[\n        ExceptionRule(httpx.TransportError, max_retries=3),\n    ],\n    max_retries=10,\n)\n\nsalesforce = Salesforce(\n    ...\n    retry_policy=retry_policy,\n)\n</code></pre> <p>After the maximum number of retries or when a timeout is reached, the client will raise an exception.</p> <p>Note</p> <p>By default, the <code>Salesforce</code> client will retry requests up to 3 times when caused by the following errors:</p> <ul> <li><code>httpx.TransportError</code> (excluding <code>httpx.TimeoutException</code>) - network issues</li> <li>Server errors (status code &gt;= 500)</li> <li><code>UNABLE_TO_LOCK_ROW</code> error</li> <li>Rate limits errors (status code 429 or <code>REQUEST_LIMIT_EXCEEDED</code> in response)</li> </ul>"},{"location":"documentation/client/#retry-policy","title":"Retry Policy","text":"<p>A <code>RetryPolicy</code> instance is used to define the conditions under which a request should be retried, how many times it should be retried, and how long to wait between retries. There are two reasons why a request can fail:</p> <ul> <li>Status code of the response is not OK (status code &gt;= 300)</li> <li>An exception is raised during the request</li> </ul> <p>To handle these two cases, you need to define <code>response_rules</code> and <code>exception_rules</code> and pass them to the <code>RetryPolicy</code> instance.</p> <pre><code>retry_policy = RetryPolicy(\n    response_rules=[...],\n    exception_rules=[...],\n    max_retries=10,\n    timeout=60,\n)\n</code></pre> <p>The logic when deciding if a request should be retried is as follows:</p> <ol> <li>Check if <code>max_retries</code> or <code>timeout</code> is reached for the request retrying context     in accordance with the client's <code>retry_policy</code> - if so, raise an exception.</li> <li>Evaluate rules in the order they were provided. If a rule:     <ul> <li>Doesn't match - move to the next rule</li> <li>Matches<ul> <li>Its <code>max_retries</code> is exhausted - raise an exception</li> <li>Its <code>max_retries</code> is not exhausted - increment its retry count, sleep,   and retry the request</li> </ul> </li> </ul> </li> <li>If none of the rules match - raise an exception.</li> </ol> <p>You can find more information about the <code>RetryPolicy</code> class in the API Reference.</p>"},{"location":"documentation/client/#response-rule","title":"Response Rule","text":"<p>A response rule is evaluated when a request fails due to a status code not being OK (status code &gt;= 300). A response rule needs a function which it calls with the response object. If the function returns <code>True</code>, the rule matches and the request will be retried. You can also specify the maximum number of retries for the rule (by default 3).</p> <pre><code>from aiosalesforce import ResponseRule\n\nresponse_rule = ResponseRule(\n    lambda response: response.status_code &gt;= 500,\n    max_retries=5,\n)\n</code></pre> <p>Function used in response rule can be asynchronous. This can be useful if you need to make an asynchronous IO operation to determine if the request should be retried. If, however, you need to make a synchronous IO operation, you should use a regular function - it will be run in a separate thread to avoid blocking the event loop.</p>"},{"location":"documentation/client/#exception-rule","title":"Exception Rule","text":"<p>An exception rule is evaluated when a request fails due to an exception being raised by <code>httpx</code>. An exception rule needs an exception type on which it retries the request. By default, it will always retry on this exception. If you need to have more control over when the request should be retried, you can specify a function which it calls with the exception object. If the function returns <code>True</code>, the rule matches and the request will be retried. You can also specify the maximum number of retries for the rule (by default 3).</p> <pre><code>from aiosalesforce import ExceptionRule\n\nexception_rule = ExceptionRule(\n    httpx.TransportError,\n    lambda exc: not isinstance(exc, httpx.TimeoutException),\n    max_retries=3,\n)\n</code></pre> <p>Similar to response rules, the function used in exception rules can be asynchronous or synchronous.</p>"},{"location":"documentation/client/#concurrency-limit","title":"Concurrency Limit","text":"<p>To limit the number of simultaneous requests to the Salesforce API, you can use the <code>concurrency_limit</code> parameter. Salesforce doesn't have a limit on the number of concurrent requests for short operations (less than 20 seconds), but generally it's a good practice to limit the number of simultaneous requests to avoid congestion-related issues.</p> <p>By default, the <code>concurrency_limit</code> is set to <code>100</code>. You can change it by passing a different value when instantiating the <code>Salesforce</code> client.</p> <pre><code>salesforce = Salesforce(\n    client=client,\n    base_url=\"https://your-instance.my.salesforce.com\",\n    auth=auth,\n    concurrency_limit=25,\n)\n</code></pre>"},{"location":"documentation/introduction/","title":"Introduction","text":""},{"location":"documentation/introduction/#overview","title":"Overview","text":"<p><code>aiosalesforce</code> is an asynchronous Python client for the Salesforce API. It allows performing the following operations against Salesforce:</p> <ul> <li>Authentication</li> <li>CRUD operations on Salesforce objects (also known as sobjects)</li> <li>Executing SOQL queries</li> <li>Bulk data operations</li> </ul> <p>The general pattern for using <code>aiosalesforce</code> is to create an authentication instance and pass it to the <code>Salesforce</code> client. The client is then used to make requests to the Salesforce APIs.</p> <pre><code>import asyncio\n\nfrom aiosalesforce import Salesforce, SoapLogin\nfrom httpx import AsyncClient\n\nauth = SoapLogin(\n    username=\"username\",\n    password=\"password\",\n    security_token=\"security-token\",\n)\n\nasync def main():\n    async with AsyncClient() as client:\n        salesforce = Salesforce(\n            client=client,\n            base_url=\"https://your-instance.my.salesforce.com\",\n            auth=auth,\n        )\n        contact = salesforce.sobject.get(\"Contact\", \"0033h00000KzZ3AAAV\")\n        print(contact)\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Note</p> <p>Since <code>aiosalesforce</code> is an asynchronous library, you need to define your functions using <code>async def</code> and use the <code>await</code> keyword when calling asynchronous methods. In subsequent sections of this documentation the definition of the asynchronous function is often ommited for brevity and it is assumed that everything is written inside one.</p>"},{"location":"documentation/introduction/#recommended-reading","title":"Recommended reading","text":"<p>As you are using <code>aiosalesforce</code>, you should familiarize yourself with the Python's <code>asyncio</code> library.</p> <p>Relevant Salesforce API documentation:</p> <ul> <li>Salesforce APIs</li> <li>Salesforce REST API</li> <li>Salesforce Bulk API</li> </ul>"},{"location":"documentation/sobject/","title":"sObject Operations","text":"<p>In Salesforce sObject is any standard or custom object. Each object has records which you can create, read, update, or delete. You can interact with sObjects using the <code>SobjectClient</code> which is exposed via the <code>sobject</code> property of the <code>Salesforce</code> client.</p> <pre><code>account = await salesforce.sobject.get('Account', '0012v00002Q8f4QAAR')\n</code></pre> <p>Information</p> <p>When you create, update, delete, or upsert a record, you must provide the <code>data</code> parameter. This parameter can be either a dictionary or a string/bytes/bytearray object which represents a dictionary serialized as JSON. Take advantage of this if you have custom data types that are not serializable by <code>orjson</code>.</p>"},{"location":"documentation/sobject/#create","title":"Create","text":"<p>To create a new record, you must provide the object name and the data for the new record. The <code>create</code> method returns the ID of the newly created record.</p> <pre><code>data = {\n    \"FirstName\": \"Jon\",\n    \"LastName\": \"Doe\",\n    \"Phone\": \"1234567890\",\n    \"Email\": \"jon.doe@example.com\",\n}\ncontact_id = await salesforce.sobject.create('Contact', data)\n</code></pre>"},{"location":"documentation/sobject/#read","title":"Read","text":"<p>To read a record, you must provide the object name and the ID of the record you want to read. The <code>get</code> method returns the record as a dictionary.</p> <pre><code>contact = await salesforce.sobject.get('Contact', contact_id)\n</code></pre> <p>By default the <code>get</code> method returns all fields for the record. If you want to get only the specific fields you want to retrieve, you can provide a list of field names in the <code>fields</code> parameter.</p> <pre><code>contact = await salesforce.sobject.get(\n    \"Contact\",\n    contact_id,\n    fields=[\"FirstName\", \"LastName\", \"Email\"],\n)\n</code></pre>"},{"location":"documentation/sobject/#update","title":"Update","text":"<p>To update a record, you must provide the object name, the ID of the record you want to update, and the data you want to update. The <code>update</code> method doesn't return anything.</p> <pre><code>data = {\n    \"Phone\": \"0987654321\",\n}\nawait salesforce.sobject.update('Contact', contact_id, data)\n</code></pre>"},{"location":"documentation/sobject/#delete","title":"Delete","text":"<p>To delete a record, you must provide the object name and the ID of the record you want to delete. The <code>delete</code> method doesn't return anything.</p> <pre><code>await salesforce.sobject.delete('Contact', contact_id)\n</code></pre>"},{"location":"documentation/sobject/#using-external-id","title":"Using External ID","text":"<p>You can use an external ID to read, delete, or upsert (create or update) a record. To read or delete a record using an external ID, you must provide the <code>external_id_field</code> parameter and set ID to the exteral ID value (instead of the record ID):</p> <pre><code>contact = await salesforce.sobject.get(\n    \"Contact\",\n    \"123456\",  # External ID value\n    \"ExternalId__c\",  # External ID field\n)\n\nawait salesforce.sobject.delete(\n    \"Contact\",\n    \"123456\",  # External ID value\n    \"ExternalId__c\",  # External ID field\n)\n</code></pre> <p>Warning</p> <p>When using an external ID, make sure that the external ID field is unique. This can be configured in Salesforce by setting the field as unique. If the are multiple records with the same external ID, you will get a <code>MoreThanOneRecordError</code> error.</p>"},{"location":"documentation/sobject/#upsert","title":"Upsert","text":"<p>To upsert a record using an external ID, you must provide the object name, external ID value and field name, and the data you want to upsert. The <code>upsert</code> method returns a dataclass with two attributes:</p> <ul> <li><code>id</code> - Salesforce ID (NOT external ID) of the upserted record</li> <li><code>created</code> - boolean value indicating whether the record was created (<code>True</code>)   or updated (<code>False</code>)</li> </ul> <pre><code>data = {\n    \"FirstName\": \"Jon\",\n    \"LastName\": \"Doe\",\n    \"Phone\": \"1234567890\",\n    \"Email\": \"jon.doe@example.com\",\n}\nresponse = await salesforce.sobject.upsert(\n    \"Contact\",\n    \"123456\",  # External ID value\n    \"ExternalId__c\",  # External ID field\n    data,\n)\noperation = \"created\" if response.created else \"updated\"\nprint(f\"{operation} record with ID {response.id}\")\n</code></pre> <p>Information</p> <p>By default, the <code>upsert</code> method checks your payload for the external ID field. If the external ID field is present, it is removed from the payload before sending the request. This is because Salesforce doesn't allow external ID fields to be included in the payload when upserting a record. The default behavior results in a slight performance penalty because your payload is deserialized and serialized (if it's string/bytes) to remove the external ID field. If you know that your payload doesn't contain the external ID field, you can set the <code>validate</code> parameter to <code>False</code> to skip the check.</p>"},{"location":"documentation/soql/","title":"SOQL Queries","text":""},{"location":"documentation/soql/#overview","title":"Overview","text":"<p>You can perform SOQL queries by using the <code>query</code> method of the <code>Salesforce</code> client. This method accepts a SOQL query string and return an asynchronous generator that yields records returned by the query.</p> <pre><code>records = []\nasync for record in client.query(\"SELECT Id, Name FROM Account\"):\n    records.append(record)\n</code></pre> <p>Warning</p> <p>The <code>query</code> method returns an asynchronous generator. You must use it with the <code>async for</code> statement to iterate over the records returned by the query.</p> <p>By default, query method returns only active records. If you need to also include archived or deleted records, you must pass the <code>include_all_records</code> parameter:</p> <pre><code>records = []\nasync for record in client.query(\n    \"SELECT Id, Name FROM Account\",\n    include_all_records=True,\n):\n    records.append(record)\n</code></pre>"},{"location":"documentation/soql/#formatting-soql-queries","title":"Formatting SOQL Queries","text":"<p>If your query contains dynamic parameters, you should use the <code>format_soql</code> function to format your query string. SOQL is generally safe by design - it is not possible to mutate (create/update/delete) records using SOQL queries. However, you may still be vulnerable to SQL injection attacks where malicious input can result in fetching data which the caller should not have access to. Therefore, it is a good practice to always use the <code>format_soql</code> function to format your query string when using dynamic parameters.</p>"},{"location":"documentation/soql/#basic-usage","title":"Basic Usage","text":"<pre><code>query = format_soql(\n    \"SELECT Id, Name FROM Account WHERE Name = {name}\",\n    name=\"My Account\",\n)\nasync for record in client.query(query):\n    ...\n</code></pre> <p>The above would produce the following query string:</p> <pre><code>SELECT Id, Name FROM Account WHERE Name = 'My Account'\n</code></pre> <p>Note</p> <p>The <code>format_soql</code> function adds single quotes around the parameter value(s) when appropriate (there are exceptions like bools, dates, numbers). You should not add your own quotes around the parameter value.</p>"},{"location":"documentation/soql/#collections","title":"Collections","text":"<p>You can also pass an array of values (can be <code>list</code>, <code>tuple</code>, or <code>set</code>):</p> <pre><code>query = format_soql(\n    \"SELECT Id, Name FROM Account WHERE Name IN {names}\",\n    names=[\"My Account\", \"Another Account\"],\n)\n</code></pre> <p>The above would produce the following query string:</p> <pre><code>SELECT Id, Name FROM Account WHERE Name IN ('My Account', 'Another Account')\n</code></pre>"},{"location":"documentation/soql/#like-operator","title":"LIKE Operator","text":"<p>When formatting expressions containing the <code>LIKE</code> operator, you should use the special format spec <code>{:like}</code>:</p> <pre><code>query = format_soql(\n    \"SELECT Id, Name FROM User WHERE Name LIKE '%{name:like}\",\n    name=\"Jon%\",\n)\n</code></pre> <p>The above would produce the following query string:</p> <pre><code>SELECT Id, Name FROM User WHERE Name LIKE '%Jon\\%'\n</code></pre> <p>Notice that when using the <code>{:like}</code> format spec, single quotes are not added around the parameter value.</p>"},{"location":"documentation/bulk/v1/","title":"Bulk API","text":"<p>Please use Bulk API 2.0.</p> <p>Note</p> <p>Bulk API is a predecessor of Bulk API 2.0. While both provide the same functionality, Bulk API 2.0 has simpler workflow, better performance, and fewer limitations. Currently, there are no plans to implement the legacy (1.0) Bulk API in <code>aiosalesforce</code>.</p>"},{"location":"documentation/bulk/v2/","title":"Bulk API 2.0","text":"<p>Bulk API 2.0 is used to perform ingest (CRUD) and query operations against Salesforce when working with large amounts of data. <code>aiosalesforce</code> exposes interface to perform these operations at a high level (similar to sObject CRUD operations) and to manage bulk jobs at a low level if needed.</p> <p>Tip</p> <p>Salesforce recommends using Bulk API when an operation involves more than 2,000 records. If you are working with a small number of records (up to a few thousand), consider using one of the composite resources instead. Generally speaking, however, it depends on your particular use case. Creating, monitoring, and managing bulk jobs requires making at least 7 REST API calls.</p>"},{"location":"documentation/bulk/v2/#ingest","title":"Ingest","text":"<p>Ingest operations are used to create (insert), update, upsert, or delete records. All bulk ingest operations are performed on a single sObject type.</p> <p>Response of the ingest operation is an object with the following attributes:</p> <ul> <li><code>jobs</code> - list of <code>JobInfo</code> objects containing metadata about jobs created to   to perform the ingest operation. A job is created for each 150,000,000 records.   Unless you exceed this number, you will always have a single job.</li> <li><code>successful_results</code> - list of dictionaries with successful results.   In addition to payload data, each dictionary contains <code>sf__Created</code> and <code>sf__Id</code>   keys. See Salesforce documentation.</li> <li><code>failed_results</code> - list of dictionaries with failed results.   In addition to payload data, each dictionary contains <code>sf__Error</code> and <code>sf__Id</code>   keys. See Salesforce documentation.</li> <li><code>unprocessed_records</code> - list of dictionaries with unprocessed records.   Does not contain any additional keys (only original payloads).   See Salesforce documentation.</li> </ul> <p>Warning</p> <p>Order of records in the response lists does not match the order of records in the request data. However, because each record in the response (for successful, failed, and unprocessed records) contains full original payload, you can use this information to match records in the request data with records in the response.</p> <p>Warning</p> <p>All results are returned as lists of dictionaries with both keys and values being strings. This is due to the fact that Bulk API 2.0 uses CSV format for data exchange. For example, <code>sf__Created</code> is a string like <code>\"true\"</code> or <code>\"false\"</code>.</p>"},{"location":"documentation/bulk/v2/#insert","title":"Insert","text":"<p>To insert records in bulk, you must provide the object name and data (sequence of dictionaries).</p> <pre><code>data = [\n    {\"FirstName\": \"Jon\", \"LastName\": \"Doe\"},\n    {\"FirstName\": \"Jane\", \"LastName\": \"Doe\"},\n]\nresult = await salesforce.bulk_v2.insert(\"Contact\", data)\nrecord_ids = [record[\"sf__Id\"] for record in result.successful_results]\n</code></pre>"},{"location":"documentation/bulk/v2/#update","title":"Update","text":"<p>To update records in bulk, you must provide the object name and data. Data must include <code>Id</code> field for each record.</p> <pre><code>data = [\n    {\"Id\": \"0031R00001K1H2IQAV\", \"FirstName\": \"Jon\", \"LastName\": \"Doe\"},\n    {\"Id\": \"0031R00001K1H2JQAV\", \"FirstName\": \"Jane\", \"LastName\": \"Doe\"},\n]\nresult = await salesforce.bulk_v2.update(\"Contact\", data)\n</code></pre>"},{"location":"documentation/bulk/v2/#delete","title":"Delete","text":"<p>To delete records in bulk, you must provide the object name and data. Data must include <code>Id</code> field for each record.</p> <pre><code>data = [\n    {\"Id\": \"0031R00001K1H2IQAV\"},\n    {\"Id\": \"0031R00001K1H2JQAV\"},\n]\nresult = await salesforce.bulk_v2.delete(\"Contact\", data)\n</code></pre>"},{"location":"documentation/bulk/v2/#upsert","title":"Upsert","text":"<p>To upsert records in bulk, you must provide the object name, external ID field name, and data. Data must include external ID field value for each record.</p> <pre><code>data = [\n    {\"ExternalId__c\": \"123\", \"FirstName\": \"Jon\", \"LastName\": \"Doe\"},\n    {\"ExternalId__c\": \"456\", \"FirstName\": \"Jane\", \"LastName\": \"Doe\"},\n]\nresult = await salesforce.bulk_v2.upsert(\"Contact\", data, \"ExternalId__c\")\n</code></pre>"},{"location":"documentation/bulk/v2/#low-level-job-management","title":"Low Level Job Management","text":"<p>You can manage individual jobs at a low level using the Ingest client. You can access it via <code>salesforce.bulk_v2.ingest</code> and it exposes the following methods:</p> <ul> <li><code>create_job</code> - create a new job for specified sObject and operation</li> <li><code>get_job</code> - get information about an existing job</li> <li><code>list_jobs</code> - list all jobs (returns an asynchronous iterator)</li> <li><code>abort_job</code> - abort an existing job</li> <li><code>delete_job</code> - delete an existing job</li> <li><code>upload_job_data</code> - upload CSV data (already converted to bytes) and set job state to   <code>UploadComplete</code></li> <li><code>perform_operation</code> - uses other methods to fully execute a bulk job. This method   is equivalent to running regular high-level bulk operations (e.g., <code>upsert</code>) but   with additional parameters.</li> </ul> <p>Example of manually executing a bulk job:</p> <pre><code>from aiosalesforce.bulk.v2._csv import (\n    deserialize_ingest_results,\n    serialize_ingest_data,\n)\n\ndata = [\n    {\"FirstName\": \"Jon\", \"LastName\": \"Doe\"},\n    {\"FirstName\": \"Jane\", \"LastName\": \"Doe\"},\n]\njob = await salesforce.bulk_v2.ingest.create_job(\"Contact\", \"insert\")\njob = await salesforce.bulk_v2.ingest.upload_job_data(\n    job.id,\n    serialize_ingest_data(data),\n)\nwhile job.state in {\"Open\", \"UploadComplete\", \"InProgress\"}:\n    await asyncio.sleep(5)\n    job = await self.get_job(job.id)\nresponse = await salesforce.request(\n    \"GET\",\n    f\"{salesforce.bulk_v2.ingest.base_url}/{job.id}/successfulResults\",\n)\nsuccessful_results = deserialize_ingest_results(response.content)\n</code></pre>"},{"location":"documentation/bulk/v2/#query","title":"Query","text":"<p>Warning</p> <p> Work in progress.</p>"},{"location":"documentation/composite/batch/","title":"Batch","text":""},{"location":"documentation/composite/batch/#overview","title":"Overview","text":"<p>Composite Batch allows executing up to 25 independent subrequests in a single request. To execute a batch of subrequests, create a batch, add subrequests to it, and then execute it:</p> <pre><code>async with salesforce.composite.batch(halt_on_error=True) as batch:\n    query = batch.query(\"SELECT Id, Name FROM Account LIMIT 10\")\n    contact = batch.sobject.create(\n        \"Contact\",\n        {\"FirstName\": \"Jon\", \"LastName\": \"Doe\"},\n    )\nprint(query.records)\nprint(contact.id)\n</code></pre> <p>You can also execute the batch without using the context manager:</p> <pre><code>batch = salesforce.composite.batch(halt_on_error=True)\nquery = batch.query(\"SELECT Id, Name FROM Account LIMIT 10\")\ncontact = batch.sobject.create(\n    \"Contact\",\n    {\"FirstName\": \"Jon\", \"LastName\": \"Doe\"},\n)\nawait batch.execute()\nprint(query.records)\nprint(contact.id)\n</code></pre> <p>You can control batch behavior using the following parameters:</p> <ul> <li><code>halt_on_error</code> - if any subrequest fails, all subsequent subrequests are skipped and   marked as failed. By default, <code>False</code>.</li> <li><code>autoraise</code> - raise an exception if any subrequest fails. By default, <code>False</code>.</li> <li><code>group_errors</code> - raise ExceptionGroup instead of the first exception   if <code>autoraise</code> is <code>True</code>. By default, <code>False</code>.</li> </ul> <p>Once a composite batch is executed, you can access the following attributes for each of its subrequests:</p> <ul> <li><code>response</code> - the response dictionary</li> <li><code>done</code> - whether the subrequest has been executed</li> <li><code>status_code</code> - HTTP status code</li> <li><code>result</code> - the result of the subrequest (response body)</li> <li><code>is_success</code> - whether the subrequest was successful</li> </ul> <p>You can also raise an exception if the subrequest failed:</p> <pre><code>subrequest.raise_for_status()\n</code></pre>"},{"location":"documentation/composite/batch/#supported-subrequests","title":"Supported Subrequests","text":""},{"location":"documentation/composite/batch/#query","title":"Query","text":"<p>Execute SOQL query and get its results:</p> <pre><code>async with salesforce.composite.batch() as batch:\n    query_accounts = batch.query(\"SELECT Id, Name FROM Account LIMIT 10\")\n    query_contacts = batch.query(\"SELECT Id, Name FROM Contact LIMIT 10\")\nprint(query_accounts.records)\nprint(query_contacts.records)\n</code></pre> <p>Subrequest results are available via the <code>records</code> attribute.</p>"},{"location":"documentation/composite/batch/#sobject","title":"sObject","text":"<p>Perform CRUD operations on sObjects using the same interface as the <code>salesforce.sobject</code> resource:</p> <pre><code>async with salesforce.composite.batch() as batch:\n    contact = batch.sobject.create(\n        \"Contact\",\n        {\"FirstName\": \"Jon\", \"LastName\": \"Doe\"},\n    )\n    account = batch.sobject.update(\n        \"Account\",\n        \"0011R00001K1H2IQAV\",\n        {\"Name\": \"New Name\"},\n    )\n    opportunity = batch.sobject.upsert(\n        \"Opportunity\",\n        \"ExternalId__c\",\n        {\"ExternalId__c\": \"123\", \"Name\": \"New Opportunity\"},\n    )\nprint(\"Created contact:\", contact.id)\nprint(\"Updated account:\", account.id)\nprint(\"Upserted opportunity:\", opportunity.id)\n</code></pre> <p>Depending on the operation, the subrequest result may contain the following attributes:</p> <ul> <li><code>create</code>: <code>id</code></li> <li><code>get</code>: <code>record</code></li> <li><code>upsert</code>: <code>id</code>, <code>created</code></li> </ul>"},{"location":"documentation/composite/composite/","title":"Composite","text":""},{"location":"documentation/composite/composite/#overview","title":"Overview","text":"<p>Composite allows executing up to 25 subrequests with the ability to reference the results of previous subrequests in subsequent subrequests. To execute a composite request, create a composite instance, add subrequests to it, and then execute it:</p> <pre><code>async with salesforce.composite(all_or_none=True) as composite:\n    account = composite.sobject.create(\n        \"Account\",\n        {\"Name\": \"Acme Corporation\"},\n    )\n    contact = composite.sobject.create(\n        \"Contact\",\n        {\"FirstName\": \"Jon\", \"LastName\": \"Doe\", \"AccountId\": account.reference.id},\n    )\nprint(account.id)\nprint(contact.id)\n</code></pre> <p>You can also execute the composite request without using the context manager:</p> <pre><code>composite = salesforce.composite(all_or_none=True)\naccount = composite.sobject.create(\n    \"Account\",\n    {\"Name\": \"Acme Corporation\"},\n)\ncontact = composite.sobject.create(\n    \"Contact\",\n    {\n        \"FirstName\": \"Jon\",\n        \"LastName\": \"Doe\",\n        \"AccountId\": account.reference.id,\n    },\n)\nawait composite.execute()\nprint(account.id)\nprint(contact.id)\n</code></pre> <p>You can control composite behavior using the following parameters:</p> <ul> <li><code>all_or_none</code> - if <code>True</code>, all subrequests are rolled back if any subrequest fails.   By default, <code>False</code>.</li> <li><code>collate_subrequests</code> - if <code>True</code>, independent subrequests are executed in parallel.   By default, <code>True</code>.</li> <li><code>autoraise</code> - raise an ExceptionGroup if any subrequest fails. By default, <code>False</code>.</li> </ul> <p>Once a composite request is executed, you can access the following attributes for each of its subrequests:</p> <ul> <li><code>response</code> - the response dictionary</li> <li><code>done</code> - whether the subrequest has been executed</li> <li><code>response_body</code> - subrequest response body</li> <li><code>response_http_headers</code> - subrequest response HTTP headers</li> <li><code>status_code</code> - HTTP status code</li> <li><code>is_success</code> - whether the subrequest was successful</li> </ul> <p>You can also raise an exception if the subrequest failed:</p> <pre><code>subrequest.raise_for_status()\n</code></pre>"},{"location":"documentation/composite/composite/#referencing-subrequests","title":"Referencing Subrequests","text":"<p>You can reference the results of previous subrequests in subsequent subrequests by using the <code>reference</code> attribute of the subrequest result. The <code>reference</code> attribute returns a special objects which supports item (<code>$[i]</code>) and attribute (<code>$.attr</code>) access. For example, <code>subrequest.reference.children[0].id</code> references the <code>id</code> attribute of the first subrequest result in the <code>children</code> attribute of the subrequest result. Specific format of the reference depends on response body structure for the referenced subrequest.</p> <pre><code>async with salesforce.composite() as composite:\n    query = composite.query(\"SELECT Id, Name FROM Account LIMIT 1\")\n    contact = composite.sobject.create(\n        \"Contact\",\n        {\n            \"FirstName\": \"Jon\",\n            \"LastName\": \"Doe\",\n            \"AccountId\": query.reference.records[0].Id,\n        },\n    )\nprint(\"Created contact:\", contact.id)\n</code></pre>"},{"location":"documentation/composite/composite/#supported-subrequests","title":"Supported Subrequests","text":""},{"location":"documentation/composite/composite/#query","title":"Query","text":"<p>Execute SOQL query and get its results:</p> <pre><code>async with salesforce.composite() as composite:\n    query_accounts = composite.query(\"SELECT Id, Name FROM Account LIMIT 10\")\n    query_contacts = composite.query(\"SELECT Id, Name FROM Contact LIMIT 10\")\nprint(query_accounts.records)\nprint(query_contacts.records)\n</code></pre> <p>Subrequest results are available via the <code>records</code> attribute.</p>"},{"location":"documentation/composite/composite/#sobject","title":"sObject","text":"<p>Perform CRUD operations on sObjects using the same interface as the <code>salesforce.sobject</code> resource:</p> <pre><code>async with salesforce.composite(all_or_none=True) as composite:\n    account = composite.sobject.update(\n        \"Account\",\n        \"0011R00001K1H2IQAV\",\n        {\"Name\": \"New Name\"},\n    )\n    contact = composite.sobject.upsert(\n        \"Contact\",\n        \"ExternalId__c\",\n        {\n            \"ExternalId__c\": \"123\",\n            \"FirstName\": \"Jon\",\n            \"LastName\": \"Doe\",\n            \"AccountId\": account.reference.id,\n        },\n    )\n    appointment = composite.sobject.create(\n        \"Appointment__c\",\n        {\n            \"Name__c\": \"Treatment 123\",\n            \"Contact__c\": contact.reference.id,\n        },\n    )\nprint(\"Updated account:\", account.id)\nprint(\"Upserted contact:\", contact.id)\nprint(\"Created appointment:\", appointment.id)\n</code></pre> <p>Depending on the operation, the subrequest result may contain the following attributes:</p> <ul> <li><code>create</code>: <code>id</code></li> <li><code>get</code>: <code>record</code></li> <li><code>upsert</code>: <code>id</code>, <code>created</code></li> </ul>"},{"location":"documentation/composite/overview/","title":"Overview","text":"<p>Salesforce has a family of composite resources which allow executing multiple operations within a single request. These are the composite resources available in <code>aiosalesforce</code> (listed in the order of increasing complexity and capability):</p> <ul> <li>Composite Batch - execute up to 25 independent subrequests</li> <li>Composite - execute up to 25 subrequests with the ability   to reference the results of previous subrequests in subsequent subrequests</li> <li>Composite graph -  work in progress</li> <li>sObject Tree -  work in progress</li> <li>sObject Collections -  work in progress</li> </ul> <p>Composite resources are exposed via the <code>composite</code> attribute of the <code>Salesforce</code> client.</p> <p>Warning</p> <p>Composite subrequests are not treated as regular requests by <code>aiosalesforce</code>. This means that retries and events are applied only to the composite request itself and not to the subrequests it contains. This is consistent with how the Bulk API works.</p>"}]}